[
    {
        "role": "system",
        "content": "You are an expert in WebAssembly. Please answer the following question. You should first describe the answer in natural language and then provide the answer in JSON format."
    },
    {
        "role": "user",
        "content": "\"\\n\\nHere is the description of the validation and execution behavior of a WebAssembly Instruction.\\n\\n{'concrete instruciton name': 'select', 'instruction format': 'select~(t^ast)^?', 'validation_description': 'valid instructions Instructions Parametric Instructions select~(t^\\\\\\\\ast)^?\\\\nIf t^\\\\\\\\ast is present, then:\\\\n\\\\nThe length of t^\\\\\\\\ast must be 1.\\\\n\\\\nThen the instruction is valid with type [t^\\\\\\\\ast~t^\\\\\\\\ast~i32] \\\\\\\\rightarrow [t^\\\\\\\\ast].\\\\n\\\\nElse:\\\\n\\\\nThe instruction is valid with type [t~t~i32] \\\\\\\\rightarrow [t], for any operand type t that matches some number type or vector type.\\\\n\\\\n\\\\\\\\frac{\\\\n}{\\\\n  C \\\\\\\\vdash select~t : [t~t~i32] \\\\\\\\rightarrow [t]\\\\n}\\\\n\\\\\\\\qquad\\\\n\\\\\\\\frac{\\\\n  \\\\\\\\vdash t \\\\\\\\leq numtype\\\\n}{\\\\n  C \\\\\\\\vdash select : [t~t~i32] \\\\\\\\rightarrow [t]\\\\n}\\\\n\\\\\\\\qquad\\\\n\\\\\\\\frac{\\\\n  \\\\\\\\vdash t \\\\\\\\leq vectype\\\\n}{\\\\n  C \\\\\\\\vdash select : [t~t~i32] \\\\\\\\rightarrow [t]\\\\n}\\\\n\\\\n\\\\n\\\\nIn future versions of WebAssembly, select may allow more than one value per choice.', 'execution_description': 'exec instructions Instructions Parametric Instructions select~(t^\\\\\\\\ast)^?\\\\nAssert: due to validation, a value of value type i32 is on the top of the stack.\\\\n\\\\nPop the value i32.const~c from the stack.\\\\n\\\\nAssert: due to validation, two more values (of the same value type) are on the top of the stack.\\\\n\\\\nPop the value val_2 from the stack.\\\\n\\\\nPop the value val_1 from the stack.\\\\n\\\\nIf c is not 0, then:\\\\n\\\\nPush the value val_1 back to the stack.\\\\n\\\\nElse:\\\\n\\\\nPush the value val_2 back to the stack.\\\\n\\\\n\\\\\\\\begin{array}{lcl@{\\\\\\\\qquad}l}\\\\nval_1~val_2~(i32.const~c)~select~t^? &\\\\\\\\hookrightarrow& val_1\\\\n  & (\\\\\\\\mathrel{if} c \\\\\\\\neq 0) \\\\\\\\\\\\\\\\\\\\nval_1~val_2~(i32.const~c)~select~t^? &\\\\\\\\hookrightarrow& val_2\\\\n  & (\\\\\\\\mathrel{if} c = 0) \\\\\\\\\\\\\\\\\\\\n\\\\\\\\end{array}\\\\n\\\\n\\\\n\\\\nIn future versions of WebAssembly, select may allow more than one value per choice.'}\\n\\nThe validation rules and execution behaviors are described in the `validation_description` part and `execution_description` part. Note that there are placeholders in these descriptions.\\n\\n\\n\\n# Your Task:\\n\\n## 1. Infer Placeholder Values:\\n   - Infer the concrete values of the placeholders in the `instruction format` part, according to the `concrete instruciton name`.\\n\\n## 2. Replace Placeholders:\\n   - Replace the placeholders in `validation_description` and `execution_description` with the concrete values inferred in step 1.\\n\\n## 3. Determine Operand and Immediate Argument Types:\\n   - Understand the `validation_description` and `execution_description` parts.\\n   - Infer the expected types of operands and immediate arguments of the instruction.\\n   - If an operand or immediate argument is optional, list all possible combinations.\\n\\nResult Format:\\n- The Result should be a mapping of the representation of an operand / immediate argument to its type.\\n- Represent the i_th operand as `op_i` and the i_th immediate argument as `imm_i`, starting from 0.\\n- Operand type candidates: i32, i64, f32, f64, v128, funcref, externref, any\\n- Immediate argument type candidates: i32, i64, f32, f64, funcref, externref, v128, local_idx, align, offset, lane_idx, table_idx, data_idx, elem_idx, func_idx, global_idx\\n\\nResult example:\\n```json\\n{\\n    \\\"op_1\\\": \\\"i32\\\",\\n    \\\"op_2\\\": \\\"i32\\\",\\n    \\\"imm_1\\\": \\\"global_idx\\\",\\n    \\\"imm_2\\\": \\\"align\\\"\\n}\\n```\\n\\nHints:\\n- Infer the semantics of the operand type 'any' and expand 'any' to suitable concrete operand types.\\n- You can use other terms to represent a type if necessary.\\n\\n## 4. Summarize Validation Rules:\\n   - Understand the validation part.\\n   - Summarize the rules between the instruction input (immediate arguments, operands), context, and the validation result (valid or invalid).\\n\\nResult Format:\\n- First describe the result as natural language and then organize the result in JSON format as a list of rules.\\n- Each rule should include InputConstraint, ContextConstraint, and Result.\\n- An example of the output\\n\\n```json\\n{\\n    \\\"InputConstraint\\\": [\\n        {\\n            \\\"v1\\\": \\\"imm_1\\\",\\n            \\\"v2\\\": \\\"4\\\",\\n            \\\"relation\\\": \\\"le\\\"\\n        }\\n    ],\\n    \\\"ContextConstraint\\\": [],\\n    \\\"Valid\\\": true\\n}\\n```\\n\\n## 5. Summarize the type of the instruction.\\n  You should display the possible parameter types and its corresponding return type.\\n  First describt the result as natural language and then summarize it as the JSON format. \\n\\nExample 1:\\n```json\\n[\\n    {\\n        \\\"param\\\": [\\\"i32\\\", \\\"i32\\\"],\\n        \\\"result\\\": [\\\"i32]\\n    }\\n]\\n```\\n\\nExample 2:\\nThe followed JSON indicates that the instruction has four possible types\\n```json\\n[\\n    {\\n        \\\"param\\\": [\\\"i32\\\", \\\"i32\\\"],\\n        \\\"result\\\": [\\\"i32]\\n    },\\n    {\\n        \\\"param\\\": [\\\"f32\\\", \\\"f32\\\"],\\n        \\\"result\\\": [\\\"f32]\\n    },\\n    {\\n        \\\"param\\\": [\\\"i64\\\", \\\"i64\\\"],\\n        \\\"result\\\": [\\\"i64]\\n    },\\n    {\\n        \\\"param\\\": [\\\"f32\\\", \\\"f32\\\"],\\n        \\\"result\\\": [\\\"f32]\\n    }\\n]\\n```\\n\\nExample 3:\\nYou can also use the type of other variables to represent the instruction type. For example, for the instruciton `global.get~imm_0`, whose parameter type is the type of the global variable (i.e., global[imm_0]) it takes, you can represent it as \\n```json\\n[\\n    {\\n        \\\"param\\\": [],\\n        \\\"result\\\": [\\\"global[imm_0].type\\\"]\\n    }\\n]\\n```\\n\\n## 6. Describe Possible Behaviors:\\n   - Think about the possible behaviors of the instruction.\\n        - Note it, consideriing operations used in the instruction, which is attached in the `op_background_info` part. You should cover the different branches in the description of the operations.\\n        - Note it, consider the attributes of the context variables related to the instruciton. If the instruciton can interactive a context variable of attributes `attr1` and `attr2`, you should distinguish them as different behaviors.\\n   - Describe the requirements on the operands, immediate arguments, and context to trigger each behavior.\\n   - Explain why the instruction input and context lead to the behavior and whether the execution will trap.\\n\\nResult Format:\\n- First describe the result as natural language and then organize the result in JSON format as a list of rules.\\n- Each rule should include InputConstraint, ContextConstraint, Description, and WhetherTrap.\\n\\nExample 1: \\n```json\\n[\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"op_0 + memarg.offset + 4\\\",\\n                \\\"v2\\\": \\\"context.Mem[0].length\\\",\\n                \\\"relation\\\": \\\"le\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [],\\n        \\\"Description\\\": \\\"The instruction stores the operand op_1 to the memory.\\\",\\n        \\\"WhetherTrap\\\": false\\n    },\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"op_0 + memarg.offset + 4\\\",\\n                \\\"v2\\\": \\\"context.Mem[0].length\\\",\\n                \\\"relation\\\": \\\"gt\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [],\\n        \\\"Description\\\": \\\"Memory out-of-bounds, leading to a trap.\\\",\\n        \\\"WhetherTrap\\\": true\\n    }\\n]\\n```\\n\\nExample 2:\\nFor another example, for the instruciton `elem.drop`, the behaviors can be described as the following, becuase the context.DATA[imm_0] can be `passive` or `active`.\\n\\n\\n```json\\n\\\"execution_part\\\": [\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"context.DATA[imm_0].attr\\\",\\n                \\\"v2\\\": [\\n                    \\\"passive\\\",\\n                    \\\"active\\\"\\n                ],\\n                \\\"relation\\\": \\\"in\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [],\\n        \\\"Description\\\": \\\"The dropped element segment can be passive or active.\\\",\\n        \\\"WhetherTrap\\\": false\\n    }\\n]\\n```\\n\\nExample 3:\\nFor the instruction `i32.eq`, which detect whether the taken operands are equal, \\n\\n```json\\n\\\"execution_part\\\": [\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"op_0\\\",\\n                \\\"v2\\\": \\\"op_1\\\",\\n                \\\"relation\\\": \\\"eq\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [],\\n        \\\"Description\\\": \\\"The two operands are equal.\\\",\\n        \\\"WhetherTrap\\\": false\\n    },\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"op_0\\\",\\n                \\\"v2\\\": \\\"op_1\\\",\\n                \\\"relation\\\": \\\"neq\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [],\\n        \\\"Description\\\": \\\"The two operands are not equal.\\\",\\n        \\\"WhetherTrap\\\": false\\n    }\\n]\\n```\\n\\n\\n\\n# Example :\\n# Example :\\n## Example 1:\\nTake the instruction  global.set~x as an example,\\nGiven the following instruction information \\n\\n\\n{\\n    \\\"concrete instruciton name\\\": \\\"global.set\\\",\\n    \\\"instruction format\\\": \\\"global.set~x\\\",\\n    \\\"validation_description\\\": \\\"valid instructions Instructions Variable Instructions global.set~x\\\\nThe global C.globals[x] must be defined in the context.\\\\n\\\\nLet mut~t be the global type C.globals[x].\\\\n\\\\nThe mutability mut must be var.\\\\n\\\\nThen the instruction is valid with type [t] \\\\\\\\rightarrow [].\\\\n\\\\n\\\\\\\\frac{\\\\n  C.globals[x] = var~t\\\\n}{\\\\n  C \\\\\\\\vdash global.set~x : [t] \\\\\\\\rightarrow []\\\\n}\\\",\\n    \\\"execution_description\\\": \\\"exec instructions Instructions Variable Instructions global.set~x\\\\nLet F be the current frame.\\\\n\\\\nAssert: due to validation, F.module.globaladdrs[x] exists.\\\\n\\\\nLet a be the global address F.module.globaladdrs[x].\\\\n\\\\nAssert: due to validation, S.globals[a] exists.\\\\n\\\\nLet glob be the global instance S.globals[a].\\\\n\\\\nAssert: due to validation, a value is on the top of the stack.\\\\n\\\\nPop the value val from the stack.\\\\n\\\\nReplace glob.value with the value val.\\\\n\\\\n\\\\\\\\begin{array}{l}\\\\n\\\\\\\\begin{array}{lcl@{\\\\\\\\qquad}l}\\\\nS; F; val~(global.set~x) &\\\\\\\\hookrightarrow& S'; F; \\\\\\\\epsilon\\\\n\\\\\\\\end{array}\\\\n\\\\\\\\\\\\\\\\ \\\\\\\\qquad\\\\n(\\\\\\\\mathrel{if} S' = S \\\\\\\\mathrel{with} globals[F.module.globaladdrs[x]].value = val) \\\\\\\\\\\\\\\\\\\\n\\\\\\\\end{array}\\\\n\\\\n\\\\n\\\\nValidation ensures that the global is, in fact, marked as mutable.\\\"\\n}\\n\\n\\nThe expected output is:\\n\\n\\n1. Infer Placeholder Values:\\n\\nThe concrete instruction name is 'global.set', and the instruction format is 'global.set~x'. Therefore, the placeholder 'x' in the instruction format represents a global index.\\n\\n2. Replace Placeholders:\\n\\nAfter replacing the placeholders in `validation_description` and `execution_description`, we get:\\n\\nValidation Description:\\n```\\nvalid instructions Instructions Variable Instructions global.set~global_idx\\nThe global C.globals[global_idx] must be defined in the context.\\n\\nLet mut~t be the global type C.globals[global_idx].\\n\\nThe mutability mut must be var.\\n\\nThen the instruction is valid with type [t] \\\\rightarrow [].\\n\\n\\\\frac{\\n  C.globals[global_idx] = var~t\\n}{\\n  C \\\\vdash global.set~global_idx : [t] \\\\rightarrow []\\n}\\n```\\n\\nExecution Description:\\n```\\nexec instructions Instructions Variable Instructions global.set~global_idx\\nLet F be the current frame.\\n\\nAssert: due to validation, F.module.globaladdrs[global_idx] exists.\\n\\nLet a be the global address F.module.globaladdrs[global_idx].\\n\\nAssert: due to validation, S.globals[a] exists.\\n\\nLet glob be the global instance S.globals[a].\\n\\nAssert: due to validation, a value is on the top of the stack.\\n\\nPop the value val from the stack.\\n\\nReplace glob.value with the value val.\\n\\n\\\\begin{array}{l}\\n\\\\begin{array}{lcl@{\\\\qquad}l}\\nS; F; val~(global.set~global_idx) &\\\\hookrightarrow& S'; F; \\\\epsilon\\n\\\\end{array}\\n\\\\\\\\ \\\\qquad\\n(\\\\mathrel{if} S' = S \\\\mathrel{with} globals[F.module.globaladdrs[global_idx]].value = val) \\\\\\\\\\n\\\\end{array}\\n\\nValidation ensures that the global is, in fact, marked as mutable.\\n```\\n\\n3. Determine Operand and Immediate Argument Types:\\n\\nThe instruction `global.set~global_idx` takes a value from the stack (operand) and a global index (immediate argument). The type of the operand should match the type of the global variable at the given index. The type of the immediate argument is a global index.\\n\\nResult:\\n```json\\n{\\n    \\\"op_0\\\": \\\"context.globals[global_idx].type\\\",\\n    \\\"imm_0\\\": \\\"u32\\\"\\n}\\n```\\n\\n4. Summarize Validation Rules:\\n\\nResult:\\n```json\\n[\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"op_0.type\\\",\\n                \\\"v2\\\": \\\"context.globals[imm_0].type\\\",\\n                \\\"relation\\\": \\\"eq\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"imm_0\\\",\\n                \\\"v2\\\": \\\"context.globals.length\\\",\\n                \\\"relation\\\": \\\"lt\\\"\\n            },\\n            {\\n                \\\"v1\\\": \\\"context.globals[imm_0].mut\\\",\\n                \\\"v2\\\": \\\"var\\\",\\n                \\\"relation\\\": \\\"eq\\\"\\n            }\\n        ],\\n        \\\"Valid\\\": true\\n    }\\n]\\n```\\n\\n5. Summarize the type of the instruction:\\n\\n\\nResult:\\n```json\\n[\\n    {\\n        \\\"param\\\": [\\\"context.globals[global_idx].type\\\"],\\n        \\\"result\\\": []\\n    }\\n]\\n```\\n\\n6. Describe Possible Behaviors:\\n\\n\\nResult:\\n```json\\n[\\n    {\\n        \\\"InputConstraint\\\": [],\\n        \\\"ContextConstraint\\\": [\\n        ],\\n        \\\"Description\\\": \\\"The instruction pops a value from the stack and sets the value of the global variable at the given index to this value.\\\",\\n        \\\"WhetherTrap\\\": false\\n    },\\n    {\\n        \\\"InputConstraint\\\": [],\\n        \\\"ContextConstraint\\\": [\\n        ],\\n        \\\"Description\\\": \\\"The instruction traps if the global variable at the given index is not defined or not mutable.\\\",\\n        \\\"WhetherTrap\\\": true\\n    }\\n]\\n```\\n\\n\\n## Example 2:\\nTake the instruction  global.set~x as an example,\\nGiven the following instruction information \\n\\n\\n{\\n    \\\"concrete instruciton name\\\": \\\"i32.store\\\",\\n    \\\"instruction format\\\": \\\"t.store~memarg and t.storeN~memarg\\\",\\n    \\\"validation_description\\\": \\\"valid instructions Instructions Memory Instructions t.store~memarg\\\\nThe memory C.mems[0] must be defined in the context.\\\\n\\\\nThe alignment 2^{memarg.align} must not be larger than the bit width of t divided by 8.\\\\n\\\\nThen the instruction is valid with type [i32~t] \\\\\\\\rightarrow [].\\\\n\\\\n\\\\\\\\frac{\\\\n  C.mems[0] = memtype\\\\n  \\\\\\\\qquad\\\\n  2^{memarg.align} \\\\\\\\leq |t|/8\\\\n}{\\\\n  C \\\\\\\\vdash t.store~memarg : [i32~t] \\\\\\\\rightarrow []\\\\n}\\\",\\n    \\\"execution_description\\\": \\\"exec instructions Instructions Memory Instructions t.store~memarg and t.store{N}~memarg\\\\nLet F be the current frame.\\\\n\\\\nAssert: due to validation, F.module.memaddrs[0] exists.\\\\n\\\\nLet a be the memory address F.module.memaddrs[0].\\\\n\\\\nAssert: due to validation, S.mems[a] exists.\\\\n\\\\nLet mem be the memory instance S.mems[a].\\\\n\\\\nAssert: due to validation, a value of value type t is on the top of the stack.\\\\n\\\\nPop the value t.const~c from the stack.\\\\n\\\\nAssert: due to validation, a value of value type i32 is on the top of the stack.\\\\n\\\\nPop the value i32.const~i from the stack.\\\\n\\\\nLet ea be the integer i + memarg.offset.\\\\n\\\\nIf N is not part of the instruction, then:\\\\n\\\\nLet N be the bit width |t| of number type t.\\\\n\\\\nIf ea + N/8 is larger than the length of mem.data, then:\\\\n\\\\nTrap.\\\\n\\\\nIf N is part of the instruction, then:\\\\n\\\\nLet n be the result of computing wrap_{|t|,N}(c).\\\\n\\\\nLet b^\\\\\\\\ast be the byte sequence bytes_{iN}(n).\\\\n\\\\nElse:\\\\n\\\\nLet b^\\\\\\\\ast be the byte sequence bytes_t(c).\\\\n\\\\nReplace the bytes mem.data[ea \\\\\\\\mathrel{\\\\\\\\mathbf:} N/8] with b^\\\\\\\\ast.\\\\n\\\\n~\\\\\\\\\\\\\\\\[-1ex]\\\\n\\\\\\\\begin{array}{l}\\\\n\\\\\\\\begin{array}{lcl@{\\\\\\\\qquad}l}\\\\nS; F; (i32.const~i)~(t.const~c)~(t.store~memarg) &\\\\\\\\hookrightarrow& S'; F; \\\\\\\\epsilon\\\\n\\\\\\\\end{array}\\\\n\\\\\\\\\\\\\\\\ \\\\\\\\qquad\\\\n  \\\\\\\\begin{array}[t]{@r@{~}l@}\\\\n  (\\\\\\\\mathrel{if} & ea = i + memarg.offset \\\\\\\\\\\\\\\\\\\\n  \\\\\\\\wedge & ea + |t|/8 \\\\\\\\leq |S.mems[F.module.memaddrs[0]].data| \\\\\\\\\\\\\\\\\\\\n  \\\\\\\\wedge & S' = S \\\\\\\\mathrel{with} mems[F.module.memaddrs[0]].data[ea \\\\\\\\mathrel{\\\\\\\\mathbf:} |t|/8] = bytes_t(c)) \\\\\\\\\\\\\\\\[1ex]\\\\n  \\\\\\\\end{array}\\\\n\\\\\\\\\\\\\\\\[1ex]\\\\n\\\\\\\\begin{array}{lcl@{\\\\\\\\qquad}l}\\\\nS; F; (i32.const~i)~(t.const~c)~(t.store{N}~memarg) &\\\\\\\\hookrightarrow& S'; F; \\\\\\\\epsilon\\\\n\\\\\\\\end{array}\\\\n\\\\\\\\\\\\\\\\ \\\\\\\\qquad\\\\n  \\\\\\\\begin{array}[t]{@r@{~}l@}\\\\n  (\\\\\\\\mathrel{if} & ea = i + memarg.offset \\\\\\\\\\\\\\\\\\\\n  \\\\\\\\wedge & ea + N/8 \\\\\\\\leq |S.mems[F.module.memaddrs[0]].data| \\\\\\\\\\\\\\\\\\\\n  \\\\\\\\wedge & S' = S \\\\\\\\mathrel{with} mems[F.module.memaddrs[0]].data[ea \\\\\\\\mathrel{\\\\\\\\mathbf:} N/8] = bytes_{iN}(wrap_{|t|,N}(c))) \\\\\\\\\\\\\\\\[1ex]\\\\n  \\\\\\\\end{array}\\\\n\\\\\\\\\\\\\\\\[1ex]\\\\n\\\\\\\\begin{array}{lcl@{\\\\\\\\qquad}l}\\\\nS; F; (i32.const~k)~(t.const~c)~(t.store{N}^?~memarg) &\\\\\\\\hookrightarrow& S; F; trap\\\\n\\\\\\\\end{array}\\\\n\\\\\\\\\\\\\\\\ \\\\\\\\qquad\\\\n  (\\\\\\\\mathrel{otherwise}) \\\\\\\\\\\\\\\\\\\\n\\\\\\\\end{array}\\\"\\n}\\n\\n\\n1. Infer Placeholder Values:\\n\\nThe concrete instruction name is 'i32.store', and the instruction format is 't.store~memarg and t.storeN~memarg'. Therefore, the placeholder 't' in the instruction format represents a value type, and 'N' represents the bit width of the value type.\\n\\n2. Replace Placeholders:\\n\\nAfter replacing the placeholders in `validation_description` and `execution_description`, we get:\\n\\nValidation Description:\\n```\\nvalid instructions Instructions Memory Instructions i32.store~memarg\\nThe memory C.mems[0] must be defined in the context.\\n\\nThe alignment 2^{memarg.align} must not be larger than the bit width of i32 divided by 8.\\n\\nThen the instruction is valid with type [i32~i32] \\\\rightarrow [].\\n\\n\\\\frac{\\n  C.mems[0] = memtype\\n  \\\\qquad\\n  2^{memarg.align} \\\\leq |i32|/8\\n}{\\n  C \\\\vdash i32.store~memarg : [i32~i32] \\\\rightarrow []\\n}\\n```\\n\\nExecution Description:\\n```\\nexec instructions Instructions Memory Instructions i32.store~memarg and i32.storeN~memarg\\nLet F be the current frame.\\n\\nAssert: due to validation, F.module.memaddrs[0] exists.\\n\\nLet a be the memory address F.module.memaddrs[0].\\n\\nAssert: due to validation, S.mems[a] exists.\\n\\nLet mem be the memory instance S.mems[a].\\n\\nAssert: due to validation, a value of value type i32 is on the top of the stack.\\n\\nPop the value i32.const~c from the stack.\\n\\nAssert: due to validation, a value of value type i32 is on the top of the stack.\\n\\nPop the value i32.const~i from the stack.\\n\\nLet ea be the integer i + memarg.offset.\\n\\nIf N is not part of the instruction, then:\\n\\nLet N be the bit width |i32| of number type i32.\\n\\nIf ea + N/8 is larger than the length of mem.data, then:\\n\\nTrap.\\n\\nIf N is part of the instruction, then:\\n\\nLet n be the result of computing wrap_{|i32|,N}(c).\\n\\nLet b^\\\\\\\\ast be the byte sequence bytes_{iN}(n).\\n\\nElse:\\n\\nLet b^\\\\\\\\ast be the byte sequence bytes_i32(c).\\n\\nReplace the bytes mem.data[ea \\\\\\\\mathrel{\\\\\\\\mathbf:} N/8] with b^\\\\\\\\ast.\\n```\\n\\n3. Determine Operand and Immediate Argument Types:\\n\\n\\nResult:\\n```json\\n{\\n    \\\"op_0\\\": \\\"i32\\\",\\n    \\\"op_1\\\": \\\"i32\\\",\\n    \\\"imm_0\\\": \\\"align\\\",\\n    \\\"imm_1\\\": \\\"offset\\\"\\n}\\n```\\n\\n4. Summarize Validation Rules:\\n\\n\\nResult:\\n```json\\n[\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"2^imm_0\\\",\\n                \\\"v2\\\": \\\"4\\\",\\n                \\\"relation\\\": \\\"le\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"0\\\",\\n                \\\"v2\\\": \\\"context.mems.length\\\",\\n                \\\"relation\\\": \\\"lt\\\"\\n            }\\n        ],\\n        \\\"Valid\\\": true\\n    }\\n]\\n```\\n\\n5. Summarize the type of the instruction:\\n\\n\\nResult:\\n```json\\n[\\n    {\\n        \\\"param\\\": [\\\"i32\\\", \\\"i32\\\"],\\n        \\\"result\\\": []\\n    }\\n]\\n```\\n\\n6. Describe Possible Behaviors:\\n\\n\\nResult:\\n```json\\n[\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"op_1 + imm_1 + 4\\\",\\n                \\\"v2\\\": \\\"context.Mem[0].length\\\",\\n                \\\"relation\\\": \\\"le\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [],\\n        \\\"Description\\\": \\\"The instruction stores the operand op_0 to the memory.\\\",\\n        \\\"WhetherTrap\\\": false\\n    },\\n    {\\n        \\\"InputConstraint\\\": [\\n            {\\n                \\\"v1\\\": \\\"op_1 + imm_1 + 4\\\",\\n                \\\"v2\\\": \\\"context.Mem[0].length\\\",\\n                \\\"relation\\\": \\\"gt\\\"\\n            }\\n        ],\\n        \\\"ContextConstraint\\\": [],\\n        \\\"Description\\\": \\\"Memory out-of-bounds, leading to a trap.\\\",\\n        \\\"WhetherTrap\\\": true\\n    }\\n]\\n```\\n\\n\\n\\nPlease re-check your answer, checking whether you consider the operations taken by the instruction and describe the possible execution behavior of the instruction in detail. For example, if a behavior is described by the text `The instruction traps if the absolute value computation is not defined.`, you should try to point out the conditions of instruciton input clearly, avoiding leaving the  field `InputConstraint` empty.\""
    }
]