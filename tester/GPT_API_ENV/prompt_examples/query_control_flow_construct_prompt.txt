[
    {
        "role": "system",
        "content": "You are an expert in WebAssembly. Please answer the following question. You should first describe the answer in natural language and then provide the answer in JSON format."
    },
    {
        "role": "system",
        "content": "Here is some description about the control flow construct syntax: \n syntax instructions Instructions Control Instructions\nInstructions in this group affect the flow of control.\n\n\\begin{array}{llcl}\nblock type & blocktype &::=&\n  typeidx ~|~ valtype^? \\\\\ninstruction & instr &::=&\n  \\dots \\\\&&|&\n  nop \\\\&&|&\n  unreachable \\\\&&|&\n  block~blocktype~instr^\\ast~end \\\\&&|&\n  loop~blocktype~instr^\\ast~end \\\\&&|&\n  if~blocktype~instr^\\ast~else~instr^\\ast~end \\\\&&|&\n  br~labelidx \\\\&&|&\n  br\\_if~labelidx \\\\&&|&\n  br\\_table~vec(labelidx)~labelidx \\\\&&|&\n  return \\\\&&|&\n  call~funcidx \\\\&&|&\n  call\\_indirect~tableidx~typeidx \\\\\n\\end{array}\n\n\n\nThe nop instruction does nothing.\n\nThe unreachable instruction causes an unconditional trap.\n\nThe block, loop and if instructions are structured instructions.\nThey bracket nested sequences of instructions, called blocks, terminated with, or separated by, end or else pseudo-instructions.\nAs the grammar prescribes, they must be well-nested.\n\nA structured instruction can consume input and produce output on the operand stack according to its annotated block type.\nIt is given either as a type index that refers to a suitable function type, or as an optional value type inline, which is a shorthand for the function type [] \\rightarrow [valtype^?].\n\nEach structured control instruction introduces an implicit label.\nLabels are targets for branch instructions that reference them with label indices.\nUnlike with other index spaces, indexing of labels is relative by nesting depth,\nthat is, label 0 refers to the innermost structured control instruction enclosing the referring branch instruction,\nwhile increasing indices refer to those farther out.\nConsequently, labels can only be referenced from within the associated structured control instruction.\nThis also implies that branches can only be directed outwards,\n“breaking” from the block of the control construct they target.\nThe exact effect depends on that control construct.\nIn case of block or if it is a forward jump,\nresuming execution after the matching end.\nIn case of loop it is a backward jump to the beginning of the loop.\n\nThis enforces structured control flow.\nIntuitively, a branch targeting a block or if behaves like a break statement in most C-like languages,\nwhile a branch targeting a loop behaves like a continue statement.\n\nBranch instructions come in several flavors:\nbr performs an unconditional branch,\nbr\\_if performs a conditional branch,\nand br\\_table performs an indirect branch through an operand indexing into the label vector that is an immediate to the instruction, or to a default target if the operand is out of bounds.\nThe return instruction is a shortcut for an unconditional branch to the outermost block, which implicitly is the body of the current function.\nTaking a branch unwinds the operand stack up to the height where the targeted structured control instruction was entered.\nHowever, branches may additionally consume operands themselves, which they push back on the operand stack after unwinding.\nForward branches require operands according to the output of the targeted block’s type, i.e., represent the values produced by the terminated block.\nBackward branches require operands according to the input of the targeted block’s type, i.e., represent the values consumed by the restarted block.\n\nThe call instruction invokes another function, consuming the necessary arguments from the stack and returning the result values of the call.\nThe call\\_indirect instruction calls a function indirectly through an operand indexing into a table that is denoted by a table index and must have type funcref.\nSince it may contain functions of heterogeneous type,\nthe callee is dynamically checked against the function type indexed by the instruction’s second immediate, and the call is aborted with a trap if it does not match."
    },
    {
        "role": "user",
        "content": "# Task description\nPlease summary the control flow construct grammar, considering the attached background imformation. Note it, here, control flow constrct refers to the nested instruction, which contains the other instructions. An instruction does not contain the other instructions is a non-control flow construct instruction, even it is a contrl instruction. \n\n- you should group the instructions that do not contains the control flow construct and represent them as  non-control flow construct instructions.\n- Note it, the back\nNote it, the background information just contains the control instrucitons. Therefore, you should include a tokento represent the non-control flow construct instructions.\n\n# Format requirement\n- First, you summary the control flow construct grammar in natural language.\n- Then, you should summary it in a structured way, such as a BNF grammar. \n- You should organize the BNF grammar as a JSON mapping. An expansion rule should looks like\n```\n\"<control_flow_name>\": ['control_flow_start', '<blocktype>', '<insts>', 'end']\n- Your response should include the following necessary information: \n    - Each kind of control flow construct should be represented as a expaonsion rule.\n    - There should be a token named \"other-instruction\" to represent the non-control Wasm instructions, which are not included in the background.\n    - There should be a token named \"non-contrl-flow-instruction\" to represent the non-control flow construct instructions, including the non control flow instructions in the background and the other instructions.\n    \n```"
    }
]