{
    "f32.abs": "The description of the operation iabs_N(i) is:\n\nLet j be the signed interpretation of i.\n\nIf j is greater than or equal to 0, then return i.\n\nElse return the negation of j, modulo 2^N.\n\n\\begin{array}{@lcll}\niabs_N(i) &=& i & (\\mathrel{if} signed_N(i) \\ge 0) \\\\\niabs_N(i) &=& -signed_N(i) \\mathbin{mod} 2^N & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "f32.add": "The description of the operation fadd_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of opposite signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return that infinity.\n\nElse if either z_1 or z_2 is an infinity, then return that infinity.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return that zero.\n\nElse if either z_1 or z_2 is a zero, then return the other operand.\n\nElse if both z_1 and z_2 are values with the same magnitude but opposite signs, then return positive zero.\n\nElse return the result of adding z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfadd_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfadd_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfadd_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfadd_N(\\pm \\infty, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(z_1, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfadd_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfadd_N(\\pm 0, \\pm 0) &=& \\pm 0 \\\\\nfadd_N(z_1, \\pm 0) &=& z_1 \\\\\nfadd_N(\\pm 0, z_2) &=& z_2 \\\\\nfadd_N(\\pm q, \\mp q) &=& +0 \\\\\nfadd_N(z_1, z_2) &=& float_N(z_1 + z_2) \\\\\n\\end{array}",
    "f32.ceil": "The description of the operation fceil_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the smallest integral value that is not smaller than z.\n\n\\begin{array}{@lcll}\nfceil_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfceil_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfceil_N(\\pm 0) &=& \\pm 0 \\\\\nfceil_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nfceil_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q \\leq i < \\pm q + 1) \\\\\n\\end{array}",
    "f32.convert_i32_s": "The description of the operation convert^{s}_{M,N}(i) is:\n\nLet j be the signed interpretation of i.\n\nReturn float_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{s}_{M,N}(i) &=& float_N(signed_M(i)) \\\\\n\\end{array}",
    "f32.convert_i32_u": "The description of the operation convert^{u}_{M,N}(i) is:\n\nReturn float_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{u}_{M,N}(i) &=& float_N(i) \\\\\n\\end{array}",
    "f32.convert_i64_s": "The description of the operation convert^{s}_{M,N}(i) is:\n\nLet j be the signed interpretation of i.\n\nReturn float_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{s}_{M,N}(i) &=& float_N(signed_M(i)) \\\\\n\\end{array}",
    "f32.convert_i64_u": "The description of the operation convert^{u}_{M,N}(i) is:\n\nReturn float_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{u}_{M,N}(i) &=& float_N(i) \\\\\n\\end{array}",
    "f32.copysign": "The description of the operation fcopysign_N(z_1, z_2) is:\n\nIf z_1 and z_2 have the same sign, then return z_1.\n\nElse return z_1 with negated sign.\n\n\\begin{array}{@lcll}\nfcopysign_N(\\pm p_1, \\pm p_2) &=& \\pm p_1 \\\\\nfcopysign_N(\\pm p_1, \\mp p_2) &=& \\mp p_1 \\\\\n\\end{array}",
    "f32.demote_f64": "The description of the operation demote_{M,N}(z) is:\n\nIf z is a canonical NaN, then return an element of nans_N\\{\\} (i.e., a canonical NaN of size N).\n\nElse if z is a NaN, then return an element of nans_N\\{\\pm nan(1)\\} (i.e., any NaN of size N).\n\nElse if z is an infinity, then return that infinity.\n\nElse if z is a zero, then return that zero.\n\nElse, return float_N(z).\n\n\\begin{array}{lll@{\\qquad}l}\ndemote_{M,N}(\\pm nan(n)) &=& nans_N\\{\\} & (\\mathrel{if} n = canon_N) \\\\\ndemote_{M,N}(\\pm nan(n)) &=& nans_N\\{+ nan(1)\\} & (\\mathrel{otherwise}) \\\\\ndemote_{M,N}(\\pm \\infty) &=& \\pm \\infty \\\\\ndemote_{M,N}(\\pm 0) &=& \\pm 0 \\\\\ndemote_{M,N}(\\pm q) &=& float_N(\\pm q) \\\\\n\\end{array}",
    "f32.div": "The description of the operation fdiv_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are zeroes, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if z_1 is an infinity and z_2 a value with equal sign, then return positive infinity.\n\nElse if z_1 is an infinity and z_2 a value with opposite sign, then return negative infinity.\n\nElse if z_2 is an infinity and z_1 a value with equal sign, then return positive zero.\n\nElse if z_2 is an infinity and z_1 a value with opposite sign, then return negative zero.\n\nElse if z_1 is a zero and z_2 a value with equal sign, then return positive zero.\n\nElse if z_1 is a zero and z_2 a value with opposite sign, then return negative zero.\n\nElse if z_2 is a zero and z_1 a value with equal sign, then return positive infinity.\n\nElse if z_2 is a zero and z_1 a value with opposite sign, then return negative infinity.\n\nElse return the result of dividing z_1 by z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfdiv_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfdiv_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfdiv_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\pm 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\mp 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfdiv_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfdiv_N(\\pm q_1, \\pm \\infty) &=& +0 \\\\\nfdiv_N(\\pm q_1, \\mp \\infty) &=& -0 \\\\\nfdiv_N(\\pm 0, \\pm q_2) &=& +0 \\\\\nfdiv_N(\\pm 0, \\mp q_2) &=& -0 \\\\\nfdiv_N(\\pm q_1, \\pm 0) &=& +\\infty \\\\\nfdiv_N(\\pm q_1, \\mp 0) &=& -\\infty \\\\\nfdiv_N(z_1, z_2) &=& float_N(z_1 / z_2) \\\\\n\\end{array}",
    "f32.eq": "The description of the operation feq_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if both z_1 and z_2 are the same value, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfeq_N(\\pm nan(n), z_2) &=& 0 \\\\\nfeq_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfeq_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfeq_N(z_1, z_2) &=& bool(z_1 = z_2) \\\\\n\\end{array}",
    "f32.floor": "The description of the operation ffloor_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse return the largest integral value that is not larger than z.\n\n\\begin{array}{@lcll}\nffloor_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nffloor_N(\\pm \\infty) &=& \\pm \\infty \\\\\nffloor_N(\\pm 0) &=& \\pm 0 \\\\\nffloor_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nffloor_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q - 1 < i \\leq \\pm q) \\\\\n\\end{array}",
    "f32.ge": "The description of the operation fge_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfge_N(\\pm nan(n), z_2) &=& 0 \\\\\nfge_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfge_N(z, z) &=& 1 \\\\\nfge_N(+ \\infty, z_2) &=& 1 \\\\\nfge_N(- \\infty, z_2) &=& 0 \\\\\nfge_N(z_1, + \\infty) &=& 0 \\\\\nfge_N(z_1, - \\infty) &=& 1 \\\\\nfge_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfge_N(z_1, z_2) &=& bool(z_1 \\geq z_2) \\\\\n\\end{array}",
    "f32.gt": "The description of the operation fgt_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 0.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if z_1 is larger than z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfgt_N(\\pm nan(n), z_2) &=& 0 \\\\\nfgt_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfgt_N(z, z) &=& 0 \\\\\nfgt_N(+ \\infty, z_2) &=& 1 \\\\\nfgt_N(- \\infty, z_2) &=& 0 \\\\\nfgt_N(z_1, + \\infty) &=& 0 \\\\\nfgt_N(z_1, - \\infty) &=& 1 \\\\\nfgt_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfgt_N(z_1, z_2) &=& bool(z_1 > z_2) \\\\\n\\end{array}",
    "f32.le": "The description of the operation fle_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 0.\n\nElse if z_1 is negative infinity, then return 1.\n\nElse if z_2 is positive infinity, then return 1.\n\nElse if z_2 is negative infinity, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfle_N(\\pm nan(n), z_2) &=& 0 \\\\\nfle_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfle_N(z, z) &=& 1 \\\\\nfle_N(+ \\infty, z_2) &=& 0 \\\\\nfle_N(- \\infty, z_2) &=& 1 \\\\\nfle_N(z_1, + \\infty) &=& 1 \\\\\nfle_N(z_1, - \\infty) &=& 0 \\\\\nfle_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfle_N(z_1, z_2) &=& bool(z_1 \\leq z_2) \\\\\n\\end{array}",
    "f32.load": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation Storage is:\n\nWhen a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:\n\n\\begin{array}{lll@{\\qquad}l}\nbytes_t(i) &=& littleendian(bits_t(i)) \\\\[1ex]\nlittleendian(\\epsilon) &=& \\epsilon \\\\\nlittleendian(d^8~{d'}^\\ast~) &=& littleendian({d'}^\\ast)~ibits_8^{-1}(d^8) \\\\\n\\end{array}\n\n\n\nAgain these functions are invertible bijections.",
    "f32.lt": "The description of the operation fgt_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 0.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if z_1 is larger than z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfgt_N(\\pm nan(n), z_2) &=& 0 \\\\\nfgt_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfgt_N(z, z) &=& 0 \\\\\nfgt_N(+ \\infty, z_2) &=& 1 \\\\\nfgt_N(- \\infty, z_2) &=& 0 \\\\\nfgt_N(z_1, + \\infty) &=& 0 \\\\\nfgt_N(z_1, - \\infty) &=& 1 \\\\\nfgt_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfgt_N(z_1, z_2) &=& bool(z_1 > z_2) \\\\\n\\end{array}",
    "f32.max": "The description of the operation fmax_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a positive infinity, then return positive infinity.\n\nElse if either z_1 or z_2 is a negative infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return positive zero.\n\nElse return the larger value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmax_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmax_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmax_N(+ \\infty, z_2) &=& + \\infty \\\\\nfmax_N(- \\infty, z_2) &=& z_2 \\\\\nfmax_N(z_1, + \\infty) &=& + \\infty \\\\\nfmax_N(z_1, - \\infty) &=& z_1 \\\\\nfmax_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfmax_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\geq z_2) \\\\\nfmax_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\geq z_1) \\\\\n\\end{array}",
    "f32.min": "The description of the operation fmin_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a negative infinity, then return negative infinity.\n\nElse if either z_1 or z_2 is a positive infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return negative zero.\n\nElse return the smaller value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmin_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmin_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmin_N(+ \\infty, z_2) &=& z_2 \\\\\nfmin_N(- \\infty, z_2) &=& - \\infty \\\\\nfmin_N(z_1, + \\infty) &=& z_1 \\\\\nfmin_N(z_1, - \\infty) &=& - \\infty \\\\\nfmin_N(\\pm 0, \\mp 0) &=& -0 \\\\\nfmin_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\leq z_2) \\\\\nfmin_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\leq z_1) \\\\\n\\end{array}",
    "f32.mul": "The description of the operation fmul_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if one of z_1 and z_2 is a zero and the other an infinity, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return positive infinity.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return negative infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with equal sign, then return positive infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with opposite sign, then return negative infinity.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return negative zero.\n\nElse return the result of multiplying z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfmul_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmul_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmul_N(\\pm \\infty, \\pm 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\mp 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm q_1, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm q_1, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfmul_N(\\pm 0, \\pm 0) &=& + 0 \\\\\nfmul_N(\\pm 0, \\mp 0) &=& - 0 \\\\\nfmul_N(z_1, z_2) &=& float_N(z_1 \\cdot z_2) \\\\\n\\end{array}",
    "f32.ne": "The description of the operation fne_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if both z_1 and z_2 are the same value, then return 0.\n\nElse return 1.\n\n\\begin{array}{@lcll}\nfne_N(\\pm nan(n), z_2) &=& 1 \\\\\nfne_N(z_1, \\pm nan(n)) &=& 1 \\\\\nfne_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfne_N(z_1, z_2) &=& bool(z_1 \\neq z_2) \\\\\n\\end{array}",
    "f32.nearest": "The description of the operation fnearest_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.\n\nElse if z is smaller than 0 but greater than or equal to -0.5, then return negative zero.\n\nElse return the integral value that is nearest to z; if two values are equally near, return the even one.\n\n\\begin{array}{@lcll}\nfnearest_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfnearest_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfnearest_N(\\pm 0) &=& \\pm 0 \\\\\nfnearest_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q \\leq 0.5) \\\\\nfnearest_N(- q) &=& -0 & (\\mathrel{if} -0.5 \\leq -q < 0) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| < 0.5) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| = 0.5 \\wedge i~even) \\\\\n\\end{array}",
    "f32.neg": "The description of the operation fneg_N(z) is:\n\nIf z is a NaN, then return z with negated sign.\n\nElse if z is an infinity, then return that infinity negated.\n\nElse if z is a zero, then return that zero negated.\n\nElse return z negated.\n\n\\begin{array}{@lcll}\nfneg_N(\\pm nan(n)) &=& \\mp nan(n) \\\\\nfneg_N(\\pm \\infty) &=& \\mp \\infty \\\\\nfneg_N(\\pm 0) &=& \\mp 0 \\\\\nfneg_N(\\pm q) &=& \\mp q \\\\\n\\end{array}",
    "f32.reinterpret_i32": "The description of the operation reinterpret_{t_1,t_2}(c) is:\n\nLet d^\\ast be the bit sequence bits_{t_1}(c).\n\nReturn the constant c' for which bits_{t_2}(c') = d^\\ast.\n\n\\begin{array}{lll@{\\qquad}l}\nreinterpret_{t_1,t_2}(c) &=& bits_{t_2}^{-1}(bits_{t_1}(c)) \\\\\n\\end{array}",
    "f32.sqrt": "The description of the operation fsqrt_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is negative infinity, then return an element of nans_N\\{\\}.\n\nElse if z is positive infinity, then return positive infinity.\n\nElse if z is a zero, then return that zero.\n\nElse if z has a negative sign, then return an element of nans_N\\{\\}.\n\nElse return the square root of z.\n\n\\begin{array}{@lcll}\nfsqrt_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfsqrt_N(- \\infty) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ \\infty) &=& + \\infty \\\\\nfsqrt_N(\\pm 0) &=& \\pm 0 \\\\\nfsqrt_N(- q) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ q) &=& float_N\\left(\\sqrt{q}\\right) \\\\\n\\end{array}",
    "f32.store": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation Storage is:\n\nWhen a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:\n\n\\begin{array}{lll@{\\qquad}l}\nbytes_t(i) &=& littleendian(bits_t(i)) \\\\[1ex]\nlittleendian(\\epsilon) &=& \\epsilon \\\\\nlittleendian(d^8~{d'}^\\ast~) &=& littleendian({d'}^\\ast)~ibits_8^{-1}(d^8) \\\\\n\\end{array}\n\n\n\nAgain these functions are invertible bijections.",
    "f32.sub": "The description of the operation fsub_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of equal signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return z_1.\n\nElse if z_1 is an infinity, then return that infinity.\n\nElse if z_2 is an infinity, then return that infinity negated.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return z_1.\n\nElse if z_2 is a zero, then return z_1.\n\nElse if z_1 is a zero, then return z_2 negated.\n\nElse if both z_1 and z_2 are the same value, then return positive zero.\n\nElse return the result of subtracting z_2 from z_1, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfsub_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfsub_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfsub_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfsub_N(\\pm \\infty, \\mp \\infty) &=& \\pm \\infty \\\\\nfsub_N(z_1, \\pm \\infty) &=& \\mp \\infty \\\\\nfsub_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfsub_N(\\pm 0, \\pm 0) &=& +0 \\\\\nfsub_N(\\pm 0, \\mp 0) &=& \\pm 0 \\\\\nfsub_N(z_1, \\pm 0) &=& z_1 \\\\\nfsub_N(\\pm 0, \\pm q_2) &=& \\mp q_2 \\\\\nfsub_N(\\pm q, \\pm q) &=& +0 \\\\\nfsub_N(z_1, z_2) &=& float_N(z_1 - z_2) \\\\\n\\end{array}\n\n\n\nUp to the non-determinism regarding NaNs, it always holds that fsub_N(z_1, z_2) = fadd_N(z_1, fneg_N(z_2)).",
    "f32.trunc": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "f32x4.abs": "The description of the operation iabs_N(i) is:\n\nLet j be the signed interpretation of i.\n\nIf j is greater than or equal to 0, then return i.\n\nElse return the negation of j, modulo 2^N.\n\n\\begin{array}{@lcll}\niabs_N(i) &=& i & (\\mathrel{if} signed_N(i) \\ge 0) \\\\\niabs_N(i) &=& -signed_N(i) \\mathbin{mod} 2^N & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "f32x4.add": "The description of the operation fadd_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of opposite signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return that infinity.\n\nElse if either z_1 or z_2 is an infinity, then return that infinity.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return that zero.\n\nElse if either z_1 or z_2 is a zero, then return the other operand.\n\nElse if both z_1 and z_2 are values with the same magnitude but opposite signs, then return positive zero.\n\nElse return the result of adding z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfadd_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfadd_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfadd_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfadd_N(\\pm \\infty, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(z_1, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfadd_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfadd_N(\\pm 0, \\pm 0) &=& \\pm 0 \\\\\nfadd_N(z_1, \\pm 0) &=& z_1 \\\\\nfadd_N(\\pm 0, z_2) &=& z_2 \\\\\nfadd_N(\\pm q, \\mp q) &=& +0 \\\\\nfadd_N(z_1, z_2) &=& float_N(z_1 + z_2) \\\\\n\\end{array}",
    "f32x4.ceil": "The description of the operation fceil_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the smallest integral value that is not smaller than z.\n\n\\begin{array}{@lcll}\nfceil_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfceil_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfceil_N(\\pm 0) &=& \\pm 0 \\\\\nfceil_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nfceil_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q \\leq i < \\pm q + 1) \\\\\n\\end{array}",
    "f32x4.convert_i32x4_s": "The description of the operation convert^{s}_{M,N}(i) is:\n\nLet j be the signed interpretation of i.\n\nReturn float_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{s}_{M,N}(i) &=& float_N(signed_M(i)) \\\\\n\\end{array}",
    "f32x4.convert_i32x4_u": "The description of the operation convert^{u}_{M,N}(i) is:\n\nReturn float_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{u}_{M,N}(i) &=& float_N(i) \\\\\n\\end{array}",
    "f32x4.demote_f64x2_zero": "The description of the operation demote_{M,N}(z) is:\n\nIf z is a canonical NaN, then return an element of nans_N\\{\\} (i.e., a canonical NaN of size N).\n\nElse if z is a NaN, then return an element of nans_N\\{\\pm nan(1)\\} (i.e., any NaN of size N).\n\nElse if z is an infinity, then return that infinity.\n\nElse if z is a zero, then return that zero.\n\nElse, return float_N(z).\n\n\\begin{array}{lll@{\\qquad}l}\ndemote_{M,N}(\\pm nan(n)) &=& nans_N\\{\\} & (\\mathrel{if} n = canon_N) \\\\\ndemote_{M,N}(\\pm nan(n)) &=& nans_N\\{+ nan(1)\\} & (\\mathrel{otherwise}) \\\\\ndemote_{M,N}(\\pm \\infty) &=& \\pm \\infty \\\\\ndemote_{M,N}(\\pm 0) &=& \\pm 0 \\\\\ndemote_{M,N}(\\pm q) &=& float_N(\\pm q) \\\\\n\\end{array}",
    "f32x4.div": "The description of the operation fdiv_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are zeroes, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if z_1 is an infinity and z_2 a value with equal sign, then return positive infinity.\n\nElse if z_1 is an infinity and z_2 a value with opposite sign, then return negative infinity.\n\nElse if z_2 is an infinity and z_1 a value with equal sign, then return positive zero.\n\nElse if z_2 is an infinity and z_1 a value with opposite sign, then return negative zero.\n\nElse if z_1 is a zero and z_2 a value with equal sign, then return positive zero.\n\nElse if z_1 is a zero and z_2 a value with opposite sign, then return negative zero.\n\nElse if z_2 is a zero and z_1 a value with equal sign, then return positive infinity.\n\nElse if z_2 is a zero and z_1 a value with opposite sign, then return negative infinity.\n\nElse return the result of dividing z_1 by z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfdiv_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfdiv_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfdiv_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\pm 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\mp 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfdiv_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfdiv_N(\\pm q_1, \\pm \\infty) &=& +0 \\\\\nfdiv_N(\\pm q_1, \\mp \\infty) &=& -0 \\\\\nfdiv_N(\\pm 0, \\pm q_2) &=& +0 \\\\\nfdiv_N(\\pm 0, \\mp q_2) &=& -0 \\\\\nfdiv_N(\\pm q_1, \\pm 0) &=& +\\infty \\\\\nfdiv_N(\\pm q_1, \\mp 0) &=& -\\infty \\\\\nfdiv_N(z_1, z_2) &=& float_N(z_1 / z_2) \\\\\n\\end{array}",
    "f32x4.eq": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation feq_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if both z_1 and z_2 are the same value, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfeq_N(\\pm nan(n), z_2) &=& 0 \\\\\nfeq_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfeq_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfeq_N(z_1, z_2) &=& bool(z_1 = z_2) \\\\\n\\end{array}",
    "f32x4.extract_lane": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation fnearest_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.\n\nElse if z is smaller than 0 but greater than or equal to -0.5, then return negative zero.\n\nElse return the integral value that is nearest to z; if two values are equally near, return the even one.\n\n\\begin{array}{@lcll}\nfnearest_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfnearest_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfnearest_N(\\pm 0) &=& \\pm 0 \\\\\nfnearest_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q \\leq 0.5) \\\\\nfnearest_N(- q) &=& -0 & (\\mathrel{if} -0.5 \\leq -q < 0) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| < 0.5) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| = 0.5 \\wedge i~even) \\\\\n\\end{array}",
    "f32x4.floor": "The description of the operation ffloor_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse return the largest integral value that is not larger than z.\n\n\\begin{array}{@lcll}\nffloor_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nffloor_N(\\pm \\infty) &=& \\pm \\infty \\\\\nffloor_N(\\pm 0) &=& \\pm 0 \\\\\nffloor_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nffloor_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q - 1 < i \\leq \\pm q) \\\\\n\\end{array}",
    "f32x4.ge": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fge_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfge_N(\\pm nan(n), z_2) &=& 0 \\\\\nfge_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfge_N(z, z) &=& 1 \\\\\nfge_N(+ \\infty, z_2) &=& 1 \\\\\nfge_N(- \\infty, z_2) &=& 0 \\\\\nfge_N(z_1, + \\infty) &=& 0 \\\\\nfge_N(z_1, - \\infty) &=& 1 \\\\\nfge_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfge_N(z_1, z_2) &=& bool(z_1 \\geq z_2) \\\\\n\\end{array}",
    "f32x4.gt": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fgt_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 0.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if z_1 is larger than z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfgt_N(\\pm nan(n), z_2) &=& 0 \\\\\nfgt_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfgt_N(z, z) &=& 0 \\\\\nfgt_N(+ \\infty, z_2) &=& 1 \\\\\nfgt_N(- \\infty, z_2) &=& 0 \\\\\nfgt_N(z_1, + \\infty) &=& 0 \\\\\nfgt_N(z_1, - \\infty) &=& 1 \\\\\nfgt_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfgt_N(z_1, z_2) &=& bool(z_1 > z_2) \\\\\n\\end{array}",
    "f32x4.le": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fle_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 0.\n\nElse if z_1 is negative infinity, then return 1.\n\nElse if z_2 is positive infinity, then return 1.\n\nElse if z_2 is negative infinity, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfle_N(\\pm nan(n), z_2) &=& 0 \\\\\nfle_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfle_N(z, z) &=& 1 \\\\\nfle_N(+ \\infty, z_2) &=& 0 \\\\\nfle_N(- \\infty, z_2) &=& 1 \\\\\nfle_N(z_1, + \\infty) &=& 1 \\\\\nfle_N(z_1, - \\infty) &=& 0 \\\\\nfle_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfle_N(z_1, z_2) &=& bool(z_1 \\leq z_2) \\\\\n\\end{array}",
    "f32x4.lt": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation Storage is:\n\nWhen a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:\n\n\\begin{array}{lll@{\\qquad}l}\nbytes_t(i) &=& littleendian(bits_t(i)) \\\\[1ex]\nlittleendian(\\epsilon) &=& \\epsilon \\\\\nlittleendian(d^8~{d'}^\\ast~) &=& littleendian({d'}^\\ast)~ibits_8^{-1}(d^8) \\\\\n\\end{array}\n\n\n\nAgain these functions are invertible bijections.",
    "f32x4.max": "The description of the operation fmax_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a positive infinity, then return positive infinity.\n\nElse if either z_1 or z_2 is a negative infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return positive zero.\n\nElse return the larger value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmax_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmax_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmax_N(+ \\infty, z_2) &=& + \\infty \\\\\nfmax_N(- \\infty, z_2) &=& z_2 \\\\\nfmax_N(z_1, + \\infty) &=& + \\infty \\\\\nfmax_N(z_1, - \\infty) &=& z_1 \\\\\nfmax_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfmax_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\geq z_2) \\\\\nfmax_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\geq z_1) \\\\\n\\end{array}",
    "f32x4.min": "The description of the operation fpmin_N(z_1, z_2) is:\n\nIf z_2 is less than z_1 then return z_2.\n\nElse return z_1.\n\n\\begin{array}{@lcll}\nfpmin_N(z_1, z_2) &=& z_2 & (\\mathrel{if} flt_N(z_2, z_1) = 1) \\\\\nfpmin_N(z_1, z_2) &=& z_1 & (\\mathrel{otherwise})\n\\end{array}",
    "f32x4.mul": "The description of the operation fmul_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if one of z_1 and z_2 is a zero and the other an infinity, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return positive infinity.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return negative infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with equal sign, then return positive infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with opposite sign, then return negative infinity.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return negative zero.\n\nElse return the result of multiplying z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfmul_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmul_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmul_N(\\pm \\infty, \\pm 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\mp 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm q_1, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm q_1, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfmul_N(\\pm 0, \\pm 0) &=& + 0 \\\\\nfmul_N(\\pm 0, \\mp 0) &=& - 0 \\\\\nfmul_N(z_1, z_2) &=& float_N(z_1 \\cdot z_2) \\\\\n\\end{array}",
    "f32x4.ne": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fne_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if both z_1 and z_2 are the same value, then return 0.\n\nElse return 1.\n\n\\begin{array}{@lcll}\nfne_N(\\pm nan(n), z_2) &=& 1 \\\\\nfne_N(z_1, \\pm nan(n)) &=& 1 \\\\\nfne_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfne_N(z_1, z_2) &=& bool(z_1 \\neq z_2) \\\\\n\\end{array}",
    "f32x4.nearest": "The description of the operation fnearest_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.\n\nElse if z is smaller than 0 but greater than or equal to -0.5, then return negative zero.\n\nElse return the integral value that is nearest to z; if two values are equally near, return the even one.\n\n\\begin{array}{@lcll}\nfnearest_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfnearest_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfnearest_N(\\pm 0) &=& \\pm 0 \\\\\nfnearest_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q \\leq 0.5) \\\\\nfnearest_N(- q) &=& -0 & (\\mathrel{if} -0.5 \\leq -q < 0) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| < 0.5) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| = 0.5 \\wedge i~even) \\\\\n\\end{array}",
    "f32x4.neg": "The description of the operation fneg_N(z) is:\n\nIf z is a NaN, then return z with negated sign.\n\nElse if z is an infinity, then return that infinity negated.\n\nElse if z is a zero, then return that zero negated.\n\nElse return z negated.\n\n\\begin{array}{@lcll}\nfneg_N(\\pm nan(n)) &=& \\mp nan(n) \\\\\nfneg_N(\\pm \\infty) &=& \\mp \\infty \\\\\nfneg_N(\\pm 0) &=& \\mp 0 \\\\\nfneg_N(\\pm q) &=& \\mp q \\\\\n\\end{array}",
    "f32x4.pmax": "The description of the operation fmax_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a positive infinity, then return positive infinity.\n\nElse if either z_1 or z_2 is a negative infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return positive zero.\n\nElse return the larger value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmax_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmax_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmax_N(+ \\infty, z_2) &=& + \\infty \\\\\nfmax_N(- \\infty, z_2) &=& z_2 \\\\\nfmax_N(z_1, + \\infty) &=& + \\infty \\\\\nfmax_N(z_1, - \\infty) &=& z_1 \\\\\nfmax_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfmax_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\geq z_2) \\\\\nfmax_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\geq z_1) \\\\\n\\end{array}",
    "f32x4.pmin": "The description of the operation fpmin_N(z_1, z_2) is:\n\nIf z_2 is less than z_1 then return z_2.\n\nElse return z_1.\n\n\\begin{array}{@lcll}\nfpmin_N(z_1, z_2) &=& z_2 & (\\mathrel{if} flt_N(z_2, z_1) = 1) \\\\\nfpmin_N(z_1, z_2) &=& z_1 & (\\mathrel{otherwise})\n\\end{array}",
    "f32x4.replace_lane": "The description of the operation fle_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 0.\n\nElse if z_1 is negative infinity, then return 1.\n\nElse if z_2 is positive infinity, then return 1.\n\nElse if z_2 is negative infinity, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfle_N(\\pm nan(n), z_2) &=& 0 \\\\\nfle_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfle_N(z, z) &=& 1 \\\\\nfle_N(+ \\infty, z_2) &=& 0 \\\\\nfle_N(- \\infty, z_2) &=& 1 \\\\\nfle_N(z_1, + \\infty) &=& 1 \\\\\nfle_N(z_1, - \\infty) &=& 0 \\\\\nfle_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfle_N(z_1, z_2) &=& bool(z_1 \\leq z_2) \\\\\n\\end{array}",
    "f32x4.splat": "The description of the operation fsqrt_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is negative infinity, then return an element of nans_N\\{\\}.\n\nElse if z is positive infinity, then return positive infinity.\n\nElse if z is a zero, then return that zero.\n\nElse if z has a negative sign, then return an element of nans_N\\{\\}.\n\nElse return the square root of z.\n\n\\begin{array}{@lcll}\nfsqrt_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfsqrt_N(- \\infty) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ \\infty) &=& + \\infty \\\\\nfsqrt_N(\\pm 0) &=& \\pm 0 \\\\\nfsqrt_N(- q) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ q) &=& float_N\\left(\\sqrt{q}\\right) \\\\\n\\end{array}",
    "f32x4.sqrt": "The description of the operation fsqrt_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is negative infinity, then return an element of nans_N\\{\\}.\n\nElse if z is positive infinity, then return positive infinity.\n\nElse if z is a zero, then return that zero.\n\nElse if z has a negative sign, then return an element of nans_N\\{\\}.\n\nElse return the square root of z.\n\n\\begin{array}{@lcll}\nfsqrt_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfsqrt_N(- \\infty) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ \\infty) &=& + \\infty \\\\\nfsqrt_N(\\pm 0) &=& \\pm 0 \\\\\nfsqrt_N(- q) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ q) &=& float_N\\left(\\sqrt{q}\\right) \\\\\n\\end{array}",
    "f32x4.sub": "The description of the operation fsub_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of equal signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return z_1.\n\nElse if z_1 is an infinity, then return that infinity.\n\nElse if z_2 is an infinity, then return that infinity negated.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return z_1.\n\nElse if z_2 is a zero, then return z_1.\n\nElse if z_1 is a zero, then return z_2 negated.\n\nElse if both z_1 and z_2 are the same value, then return positive zero.\n\nElse return the result of subtracting z_2 from z_1, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfsub_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfsub_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfsub_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfsub_N(\\pm \\infty, \\mp \\infty) &=& \\pm \\infty \\\\\nfsub_N(z_1, \\pm \\infty) &=& \\mp \\infty \\\\\nfsub_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfsub_N(\\pm 0, \\pm 0) &=& +0 \\\\\nfsub_N(\\pm 0, \\mp 0) &=& \\pm 0 \\\\\nfsub_N(z_1, \\pm 0) &=& z_1 \\\\\nfsub_N(\\pm 0, \\pm q_2) &=& \\mp q_2 \\\\\nfsub_N(\\pm q, \\pm q) &=& +0 \\\\\nfsub_N(z_1, z_2) &=& float_N(z_1 - z_2) \\\\\n\\end{array}\n\n\n\nUp to the non-determinism regarding NaNs, it always holds that fsub_N(z_1, z_2) = fadd_N(z_1, fneg_N(z_2)).",
    "f32x4.trunc": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "f64.abs": "The description of the operation iabs_N(i) is:\n\nLet j be the signed interpretation of i.\n\nIf j is greater than or equal to 0, then return i.\n\nElse return the negation of j, modulo 2^N.\n\n\\begin{array}{@lcll}\niabs_N(i) &=& i & (\\mathrel{if} signed_N(i) \\ge 0) \\\\\niabs_N(i) &=& -signed_N(i) \\mathbin{mod} 2^N & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "f64.add": "The description of the operation fadd_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of opposite signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return that infinity.\n\nElse if either z_1 or z_2 is an infinity, then return that infinity.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return that zero.\n\nElse if either z_1 or z_2 is a zero, then return the other operand.\n\nElse if both z_1 and z_2 are values with the same magnitude but opposite signs, then return positive zero.\n\nElse return the result of adding z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfadd_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfadd_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfadd_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfadd_N(\\pm \\infty, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(z_1, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfadd_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfadd_N(\\pm 0, \\pm 0) &=& \\pm 0 \\\\\nfadd_N(z_1, \\pm 0) &=& z_1 \\\\\nfadd_N(\\pm 0, z_2) &=& z_2 \\\\\nfadd_N(\\pm q, \\mp q) &=& +0 \\\\\nfadd_N(z_1, z_2) &=& float_N(z_1 + z_2) \\\\\n\\end{array}",
    "f64.ceil": "The description of the operation fceil_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the smallest integral value that is not smaller than z.\n\n\\begin{array}{@lcll}\nfceil_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfceil_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfceil_N(\\pm 0) &=& \\pm 0 \\\\\nfceil_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nfceil_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q \\leq i < \\pm q + 1) \\\\\n\\end{array}",
    "f64.convert_i32_s": "The description of the operation convert^{s}_{M,N}(i) is:\n\nLet j be the signed interpretation of i.\n\nReturn float_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{s}_{M,N}(i) &=& float_N(signed_M(i)) \\\\\n\\end{array}",
    "f64.convert_i32_u": "The description of the operation convert^{u}_{M,N}(i) is:\n\nReturn float_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{u}_{M,N}(i) &=& float_N(i) \\\\\n\\end{array}",
    "f64.convert_i64_s": "The description of the operation convert^{s}_{M,N}(i) is:\n\nLet j be the signed interpretation of i.\n\nReturn float_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{s}_{M,N}(i) &=& float_N(signed_M(i)) \\\\\n\\end{array}",
    "f64.convert_i64_u": "The description of the operation convert^{u}_{M,N}(i) is:\n\nReturn float_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{u}_{M,N}(i) &=& float_N(i) \\\\\n\\end{array}",
    "f64.copysign": "The description of the operation fcopysign_N(z_1, z_2) is:\n\nIf z_1 and z_2 have the same sign, then return z_1.\n\nElse return z_1 with negated sign.\n\n\\begin{array}{@lcll}\nfcopysign_N(\\pm p_1, \\pm p_2) &=& \\pm p_1 \\\\\nfcopysign_N(\\pm p_1, \\mp p_2) &=& \\mp p_1 \\\\\n\\end{array}",
    "f64.div": "The description of the operation fdiv_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are zeroes, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if z_1 is an infinity and z_2 a value with equal sign, then return positive infinity.\n\nElse if z_1 is an infinity and z_2 a value with opposite sign, then return negative infinity.\n\nElse if z_2 is an infinity and z_1 a value with equal sign, then return positive zero.\n\nElse if z_2 is an infinity and z_1 a value with opposite sign, then return negative zero.\n\nElse if z_1 is a zero and z_2 a value with equal sign, then return positive zero.\n\nElse if z_1 is a zero and z_2 a value with opposite sign, then return negative zero.\n\nElse if z_2 is a zero and z_1 a value with equal sign, then return positive infinity.\n\nElse if z_2 is a zero and z_1 a value with opposite sign, then return negative infinity.\n\nElse return the result of dividing z_1 by z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfdiv_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfdiv_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfdiv_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\pm 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\mp 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfdiv_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfdiv_N(\\pm q_1, \\pm \\infty) &=& +0 \\\\\nfdiv_N(\\pm q_1, \\mp \\infty) &=& -0 \\\\\nfdiv_N(\\pm 0, \\pm q_2) &=& +0 \\\\\nfdiv_N(\\pm 0, \\mp q_2) &=& -0 \\\\\nfdiv_N(\\pm q_1, \\pm 0) &=& +\\infty \\\\\nfdiv_N(\\pm q_1, \\mp 0) &=& -\\infty \\\\\nfdiv_N(z_1, z_2) &=& float_N(z_1 / z_2) \\\\\n\\end{array}",
    "f64.eq": "The description of the operation feq_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if both z_1 and z_2 are the same value, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfeq_N(\\pm nan(n), z_2) &=& 0 \\\\\nfeq_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfeq_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfeq_N(z_1, z_2) &=& bool(z_1 = z_2) \\\\\n\\end{array}",
    "f64.floor": "The description of the operation ffloor_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse return the largest integral value that is not larger than z.\n\n\\begin{array}{@lcll}\nffloor_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nffloor_N(\\pm \\infty) &=& \\pm \\infty \\\\\nffloor_N(\\pm 0) &=& \\pm 0 \\\\\nffloor_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nffloor_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q - 1 < i \\leq \\pm q) \\\\\n\\end{array}",
    "f64.ge": "The description of the operation fge_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfge_N(\\pm nan(n), z_2) &=& 0 \\\\\nfge_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfge_N(z, z) &=& 1 \\\\\nfge_N(+ \\infty, z_2) &=& 1 \\\\\nfge_N(- \\infty, z_2) &=& 0 \\\\\nfge_N(z_1, + \\infty) &=& 0 \\\\\nfge_N(z_1, - \\infty) &=& 1 \\\\\nfge_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfge_N(z_1, z_2) &=& bool(z_1 \\geq z_2) \\\\\n\\end{array}",
    "f64.gt": "The description of the operation fgt_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 0.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if z_1 is larger than z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfgt_N(\\pm nan(n), z_2) &=& 0 \\\\\nfgt_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfgt_N(z, z) &=& 0 \\\\\nfgt_N(+ \\infty, z_2) &=& 1 \\\\\nfgt_N(- \\infty, z_2) &=& 0 \\\\\nfgt_N(z_1, + \\infty) &=& 0 \\\\\nfgt_N(z_1, - \\infty) &=& 1 \\\\\nfgt_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfgt_N(z_1, z_2) &=& bool(z_1 > z_2) \\\\\n\\end{array}",
    "f64.le": "The description of the operation fle_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 0.\n\nElse if z_1 is negative infinity, then return 1.\n\nElse if z_2 is positive infinity, then return 1.\n\nElse if z_2 is negative infinity, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfle_N(\\pm nan(n), z_2) &=& 0 \\\\\nfle_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfle_N(z, z) &=& 1 \\\\\nfle_N(+ \\infty, z_2) &=& 0 \\\\\nfle_N(- \\infty, z_2) &=& 1 \\\\\nfle_N(z_1, + \\infty) &=& 1 \\\\\nfle_N(z_1, - \\infty) &=& 0 \\\\\nfle_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfle_N(z_1, z_2) &=& bool(z_1 \\leq z_2) \\\\\n\\end{array}",
    "f64.load": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation Storage is:\n\nWhen a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:\n\n\\begin{array}{lll@{\\qquad}l}\nbytes_t(i) &=& littleendian(bits_t(i)) \\\\[1ex]\nlittleendian(\\epsilon) &=& \\epsilon \\\\\nlittleendian(d^8~{d'}^\\ast~) &=& littleendian({d'}^\\ast)~ibits_8^{-1}(d^8) \\\\\n\\end{array}\n\n\n\nAgain these functions are invertible bijections.",
    "f64.lt": "The description of the operation fgt_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 0.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if z_1 is larger than z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfgt_N(\\pm nan(n), z_2) &=& 0 \\\\\nfgt_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfgt_N(z, z) &=& 0 \\\\\nfgt_N(+ \\infty, z_2) &=& 1 \\\\\nfgt_N(- \\infty, z_2) &=& 0 \\\\\nfgt_N(z_1, + \\infty) &=& 0 \\\\\nfgt_N(z_1, - \\infty) &=& 1 \\\\\nfgt_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfgt_N(z_1, z_2) &=& bool(z_1 > z_2) \\\\\n\\end{array}",
    "f64.max": "The description of the operation fmax_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a positive infinity, then return positive infinity.\n\nElse if either z_1 or z_2 is a negative infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return positive zero.\n\nElse return the larger value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmax_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmax_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmax_N(+ \\infty, z_2) &=& + \\infty \\\\\nfmax_N(- \\infty, z_2) &=& z_2 \\\\\nfmax_N(z_1, + \\infty) &=& + \\infty \\\\\nfmax_N(z_1, - \\infty) &=& z_1 \\\\\nfmax_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfmax_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\geq z_2) \\\\\nfmax_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\geq z_1) \\\\\n\\end{array}",
    "f64.min": "The description of the operation fmin_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a negative infinity, then return negative infinity.\n\nElse if either z_1 or z_2 is a positive infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return negative zero.\n\nElse return the smaller value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmin_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmin_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmin_N(+ \\infty, z_2) &=& z_2 \\\\\nfmin_N(- \\infty, z_2) &=& - \\infty \\\\\nfmin_N(z_1, + \\infty) &=& z_1 \\\\\nfmin_N(z_1, - \\infty) &=& - \\infty \\\\\nfmin_N(\\pm 0, \\mp 0) &=& -0 \\\\\nfmin_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\leq z_2) \\\\\nfmin_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\leq z_1) \\\\\n\\end{array}",
    "f64.mul": "The description of the operation fmul_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if one of z_1 and z_2 is a zero and the other an infinity, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return positive infinity.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return negative infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with equal sign, then return positive infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with opposite sign, then return negative infinity.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return negative zero.\n\nElse return the result of multiplying z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfmul_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmul_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmul_N(\\pm \\infty, \\pm 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\mp 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm q_1, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm q_1, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfmul_N(\\pm 0, \\pm 0) &=& + 0 \\\\\nfmul_N(\\pm 0, \\mp 0) &=& - 0 \\\\\nfmul_N(z_1, z_2) &=& float_N(z_1 \\cdot z_2) \\\\\n\\end{array}",
    "f64.ne": "The description of the operation fne_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if both z_1 and z_2 are the same value, then return 0.\n\nElse return 1.\n\n\\begin{array}{@lcll}\nfne_N(\\pm nan(n), z_2) &=& 1 \\\\\nfne_N(z_1, \\pm nan(n)) &=& 1 \\\\\nfne_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfne_N(z_1, z_2) &=& bool(z_1 \\neq z_2) \\\\\n\\end{array}",
    "f64.nearest": "The description of the operation fnearest_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.\n\nElse if z is smaller than 0 but greater than or equal to -0.5, then return negative zero.\n\nElse return the integral value that is nearest to z; if two values are equally near, return the even one.\n\n\\begin{array}{@lcll}\nfnearest_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfnearest_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfnearest_N(\\pm 0) &=& \\pm 0 \\\\\nfnearest_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q \\leq 0.5) \\\\\nfnearest_N(- q) &=& -0 & (\\mathrel{if} -0.5 \\leq -q < 0) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| < 0.5) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| = 0.5 \\wedge i~even) \\\\\n\\end{array}",
    "f64.neg": "The description of the operation fneg_N(z) is:\n\nIf z is a NaN, then return z with negated sign.\n\nElse if z is an infinity, then return that infinity negated.\n\nElse if z is a zero, then return that zero negated.\n\nElse return z negated.\n\n\\begin{array}{@lcll}\nfneg_N(\\pm nan(n)) &=& \\mp nan(n) \\\\\nfneg_N(\\pm \\infty) &=& \\mp \\infty \\\\\nfneg_N(\\pm 0) &=& \\mp 0 \\\\\nfneg_N(\\pm q) &=& \\mp q \\\\\n\\end{array}",
    "f64.promote_f32": "The description of the operation promote_{M,N}(z) is:\n\nIf z is a canonical NaN, then return an element of nans_N\\{\\} (i.e., a canonical NaN of size N).\n\nElse if z is a NaN, then return an element of nans_N\\{\\pm nan(1)\\} (i.e., any arithmetic NaN of size N).\n\nElse, return z.\n\n\\begin{array}{lll@{\\qquad}l}\npromote_{M,N}(\\pm nan(n)) &=& nans_N\\{\\} & (\\mathrel{if} n = canon_N) \\\\\npromote_{M,N}(\\pm nan(n)) &=& nans_N\\{+ nan(1)\\} & (\\mathrel{otherwise}) \\\\\npromote_{M,N}(z) &=& z \\\\\n\\end{array}",
    "f64.reinterpret_i64": "The description of the operation reinterpret_{t_1,t_2}(c) is:\n\nLet d^\\ast be the bit sequence bits_{t_1}(c).\n\nReturn the constant c' for which bits_{t_2}(c') = d^\\ast.\n\n\\begin{array}{lll@{\\qquad}l}\nreinterpret_{t_1,t_2}(c) &=& bits_{t_2}^{-1}(bits_{t_1}(c)) \\\\\n\\end{array}",
    "f64.sqrt": "The description of the operation fsqrt_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is negative infinity, then return an element of nans_N\\{\\}.\n\nElse if z is positive infinity, then return positive infinity.\n\nElse if z is a zero, then return that zero.\n\nElse if z has a negative sign, then return an element of nans_N\\{\\}.\n\nElse return the square root of z.\n\n\\begin{array}{@lcll}\nfsqrt_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfsqrt_N(- \\infty) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ \\infty) &=& + \\infty \\\\\nfsqrt_N(\\pm 0) &=& \\pm 0 \\\\\nfsqrt_N(- q) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ q) &=& float_N\\left(\\sqrt{q}\\right) \\\\\n\\end{array}",
    "f64.store": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation Storage is:\n\nWhen a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:\n\n\\begin{array}{lll@{\\qquad}l}\nbytes_t(i) &=& littleendian(bits_t(i)) \\\\[1ex]\nlittleendian(\\epsilon) &=& \\epsilon \\\\\nlittleendian(d^8~{d'}^\\ast~) &=& littleendian({d'}^\\ast)~ibits_8^{-1}(d^8) \\\\\n\\end{array}\n\n\n\nAgain these functions are invertible bijections.",
    "f64.sub": "The description of the operation fsub_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of equal signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return z_1.\n\nElse if z_1 is an infinity, then return that infinity.\n\nElse if z_2 is an infinity, then return that infinity negated.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return z_1.\n\nElse if z_2 is a zero, then return z_1.\n\nElse if z_1 is a zero, then return z_2 negated.\n\nElse if both z_1 and z_2 are the same value, then return positive zero.\n\nElse return the result of subtracting z_2 from z_1, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfsub_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfsub_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfsub_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfsub_N(\\pm \\infty, \\mp \\infty) &=& \\pm \\infty \\\\\nfsub_N(z_1, \\pm \\infty) &=& \\mp \\infty \\\\\nfsub_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfsub_N(\\pm 0, \\pm 0) &=& +0 \\\\\nfsub_N(\\pm 0, \\mp 0) &=& \\pm 0 \\\\\nfsub_N(z_1, \\pm 0) &=& z_1 \\\\\nfsub_N(\\pm 0, \\pm q_2) &=& \\mp q_2 \\\\\nfsub_N(\\pm q, \\pm q) &=& +0 \\\\\nfsub_N(z_1, z_2) &=& float_N(z_1 - z_2) \\\\\n\\end{array}\n\n\n\nUp to the non-determinism regarding NaNs, it always holds that fsub_N(z_1, z_2) = fadd_N(z_1, fneg_N(z_2)).",
    "f64.trunc": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "f64x2.abs": "The description of the operation fabs_N(z) is:\n\nIf z is a NaN, then return z with positive sign.\n\nElse if z is an infinity, then return positive infinity.\n\nElse if z is a zero, then return positive zero.\n\nElse if z is a positive value, then z.\n\nElse return z negated.\n\n\\begin{array}{@lcll}\nfabs_N(\\pm nan(n)) &=& +nan(n) \\\\\nfabs_N(\\pm \\infty) &=& +\\infty \\\\\nfabs_N(\\pm 0) &=& +0 \\\\\nfabs_N(\\pm q) &=& +q \\\\\n\\end{array}",
    "f64x2.add": "The description of the operation fadd_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of opposite signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return that infinity.\n\nElse if either z_1 or z_2 is an infinity, then return that infinity.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return that zero.\n\nElse if either z_1 or z_2 is a zero, then return the other operand.\n\nElse if both z_1 and z_2 are values with the same magnitude but opposite signs, then return positive zero.\n\nElse return the result of adding z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfadd_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfadd_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfadd_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfadd_N(\\pm \\infty, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(z_1, \\pm \\infty) &=& \\pm \\infty \\\\\nfadd_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfadd_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfadd_N(\\pm 0, \\pm 0) &=& \\pm 0 \\\\\nfadd_N(z_1, \\pm 0) &=& z_1 \\\\\nfadd_N(\\pm 0, z_2) &=& z_2 \\\\\nfadd_N(\\pm q, \\mp q) &=& +0 \\\\\nfadd_N(z_1, z_2) &=& float_N(z_1 + z_2) \\\\\n\\end{array}",
    "f64x2.ceil": "The description of the operation fceil_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the smallest integral value that is not smaller than z.\n\n\\begin{array}{@lcll}\nfceil_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfceil_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfceil_N(\\pm 0) &=& \\pm 0 \\\\\nfceil_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nfceil_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q \\leq i < \\pm q + 1) \\\\\n\\end{array}",
    "f64x2.convert_low_i32x4_s": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "f64x2.convert_low_i32x4_u": "The description of the operation convert^{u}_{M,N}(i) is:\n\nReturn float_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nconvert^{u}_{M,N}(i) &=& float_N(i) \\\\\n\\end{array}",
    "f64x2.div": "The description of the operation fdiv_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are zeroes, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if z_1 is an infinity and z_2 a value with equal sign, then return positive infinity.\n\nElse if z_1 is an infinity and z_2 a value with opposite sign, then return negative infinity.\n\nElse if z_2 is an infinity and z_1 a value with equal sign, then return positive zero.\n\nElse if z_2 is an infinity and z_1 a value with opposite sign, then return negative zero.\n\nElse if z_1 is a zero and z_2 a value with equal sign, then return positive zero.\n\nElse if z_1 is a zero and z_2 a value with opposite sign, then return negative zero.\n\nElse if z_2 is a zero and z_1 a value with equal sign, then return positive infinity.\n\nElse if z_2 is a zero and z_1 a value with opposite sign, then return negative infinity.\n\nElse return the result of dividing z_1 by z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfdiv_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfdiv_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfdiv_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\pm 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm 0, \\mp 0) &=& nans_N\\{\\} \\\\\nfdiv_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfdiv_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfdiv_N(\\pm q_1, \\pm \\infty) &=& +0 \\\\\nfdiv_N(\\pm q_1, \\mp \\infty) &=& -0 \\\\\nfdiv_N(\\pm 0, \\pm q_2) &=& +0 \\\\\nfdiv_N(\\pm 0, \\mp q_2) &=& -0 \\\\\nfdiv_N(\\pm q_1, \\pm 0) &=& +\\infty \\\\\nfdiv_N(\\pm q_1, \\mp 0) &=& -\\infty \\\\\nfdiv_N(z_1, z_2) &=& float_N(z_1 / z_2) \\\\\n\\end{array}",
    "f64x2.eq": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation feq_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if both z_1 and z_2 are the same value, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfeq_N(\\pm nan(n), z_2) &=& 0 \\\\\nfeq_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfeq_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfeq_N(z_1, z_2) &=& bool(z_1 = z_2) \\\\\n\\end{array}",
    "f64x2.extract_lane": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation fle_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 0.\n\nElse if z_1 is negative infinity, then return 1.\n\nElse if z_2 is positive infinity, then return 1.\n\nElse if z_2 is negative infinity, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfle_N(\\pm nan(n), z_2) &=& 0 \\\\\nfle_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfle_N(z, z) &=& 1 \\\\\nfle_N(+ \\infty, z_2) &=& 0 \\\\\nfle_N(- \\infty, z_2) &=& 1 \\\\\nfle_N(z_1, + \\infty) &=& 1 \\\\\nfle_N(z_1, - \\infty) &=& 0 \\\\\nfle_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfle_N(z_1, z_2) &=& bool(z_1 \\leq z_2) \\\\\n\\end{array}",
    "f64x2.floor": "The description of the operation ffloor_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse return the largest integral value that is not larger than z.\n\n\\begin{array}{@lcll}\nffloor_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nffloor_N(\\pm \\infty) &=& \\pm \\infty \\\\\nffloor_N(\\pm 0) &=& \\pm 0 \\\\\nffloor_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nffloor_N(\\pm q) &=& float_N(i) & (\\mathrel{if} \\pm q - 1 < i \\leq \\pm q) \\\\\n\\end{array}",
    "f64x2.ge": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fge_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfge_N(\\pm nan(n), z_2) &=& 0 \\\\\nfge_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfge_N(z, z) &=& 1 \\\\\nfge_N(+ \\infty, z_2) &=& 1 \\\\\nfge_N(- \\infty, z_2) &=& 0 \\\\\nfge_N(z_1, + \\infty) &=& 0 \\\\\nfge_N(z_1, - \\infty) &=& 1 \\\\\nfge_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfge_N(z_1, z_2) &=& bool(z_1 \\geq z_2) \\\\\n\\end{array}",
    "f64x2.gt": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fgt_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 0.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if z_1 is larger than z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfgt_N(\\pm nan(n), z_2) &=& 0 \\\\\nfgt_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfgt_N(z, z) &=& 0 \\\\\nfgt_N(+ \\infty, z_2) &=& 1 \\\\\nfgt_N(- \\infty, z_2) &=& 0 \\\\\nfgt_N(z_1, + \\infty) &=& 0 \\\\\nfgt_N(z_1, - \\infty) &=& 1 \\\\\nfgt_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfgt_N(z_1, z_2) &=& bool(z_1 > z_2) \\\\\n\\end{array}",
    "f64x2.le": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fle_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 1.\n\nElse if z_1 is positive infinity, then return 0.\n\nElse if z_1 is negative infinity, then return 1.\n\nElse if z_2 is positive infinity, then return 1.\n\nElse if z_2 is negative infinity, then return 0.\n\nElse if both z_1 and z_2 are zeroes, then return 1.\n\nElse if z_1 is smaller than or equal to z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfle_N(\\pm nan(n), z_2) &=& 0 \\\\\nfle_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfle_N(z, z) &=& 1 \\\\\nfle_N(+ \\infty, z_2) &=& 0 \\\\\nfle_N(- \\infty, z_2) &=& 1 \\\\\nfle_N(z_1, + \\infty) &=& 1 \\\\\nfle_N(z_1, - \\infty) &=& 0 \\\\\nfle_N(\\pm 0, \\mp 0) &=& 1 \\\\\nfle_N(z_1, z_2) &=& bool(z_1 \\leq z_2) \\\\\n\\end{array}",
    "f64x2.lt": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fgt_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 0.\n\nElse if z_1 and z_2 are the same value, then return 0.\n\nElse if z_1 is positive infinity, then return 1.\n\nElse if z_1 is negative infinity, then return 0.\n\nElse if z_2 is positive infinity, then return 0.\n\nElse if z_2 is negative infinity, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if z_1 is larger than z_2, then return 1.\n\nElse return 0.\n\n\\begin{array}{@lcll}\nfgt_N(\\pm nan(n), z_2) &=& 0 \\\\\nfgt_N(z_1, \\pm nan(n)) &=& 0 \\\\\nfgt_N(z, z) &=& 0 \\\\\nfgt_N(+ \\infty, z_2) &=& 1 \\\\\nfgt_N(- \\infty, z_2) &=& 0 \\\\\nfgt_N(z_1, + \\infty) &=& 0 \\\\\nfgt_N(z_1, - \\infty) &=& 1 \\\\\nfgt_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfgt_N(z_1, z_2) &=& bool(z_1 > z_2) \\\\\n\\end{array}",
    "f64x2.max": "The description of the operation fmax_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a positive infinity, then return positive infinity.\n\nElse if either z_1 or z_2 is a negative infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return positive zero.\n\nElse return the larger value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmax_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmax_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmax_N(+ \\infty, z_2) &=& + \\infty \\\\\nfmax_N(- \\infty, z_2) &=& z_2 \\\\\nfmax_N(z_1, + \\infty) &=& + \\infty \\\\\nfmax_N(z_1, - \\infty) &=& z_1 \\\\\nfmax_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfmax_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\geq z_2) \\\\\nfmax_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\geq z_1) \\\\\n\\end{array}",
    "f64x2.min": "The description of the operation fmin_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a negative infinity, then return negative infinity.\n\nElse if either z_1 or z_2 is a positive infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return negative zero.\n\nElse return the smaller value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmin_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmin_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmin_N(+ \\infty, z_2) &=& z_2 \\\\\nfmin_N(- \\infty, z_2) &=& - \\infty \\\\\nfmin_N(z_1, + \\infty) &=& z_1 \\\\\nfmin_N(z_1, - \\infty) &=& - \\infty \\\\\nfmin_N(\\pm 0, \\mp 0) &=& -0 \\\\\nfmin_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\leq z_2) \\\\\nfmin_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\leq z_1) \\\\\n\\end{array}",
    "f64x2.mul": "The description of the operation fmul_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if one of z_1 and z_2 is a zero and the other an infinity, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return positive infinity.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return negative infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with equal sign, then return positive infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with opposite sign, then return negative infinity.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return negative zero.\n\nElse return the result of multiplying z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfmul_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmul_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmul_N(\\pm \\infty, \\pm 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\mp 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm q_1, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm q_1, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfmul_N(\\pm 0, \\pm 0) &=& + 0 \\\\\nfmul_N(\\pm 0, \\mp 0) &=& - 0 \\\\\nfmul_N(z_1, z_2) &=& float_N(z_1 \\cdot z_2) \\\\\n\\end{array}",
    "f64x2.ne": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation fne_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return 1.\n\nElse if both z_1 and z_2 are zeroes, then return 0.\n\nElse if both z_1 and z_2 are the same value, then return 0.\n\nElse return 1.\n\n\\begin{array}{@lcll}\nfne_N(\\pm nan(n), z_2) &=& 1 \\\\\nfne_N(z_1, \\pm nan(n)) &=& 1 \\\\\nfne_N(\\pm 0, \\mp 0) &=& 0 \\\\\nfne_N(z_1, z_2) &=& bool(z_1 \\neq z_2) \\\\\n\\end{array}",
    "f64x2.nearest": "The description of the operation fnearest_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.\n\nElse if z is smaller than 0 but greater than or equal to -0.5, then return negative zero.\n\nElse return the integral value that is nearest to z; if two values are equally near, return the even one.\n\n\\begin{array}{@lcll}\nfnearest_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfnearest_N(\\pm \\infty) &=& \\pm \\infty \\\\\nfnearest_N(\\pm 0) &=& \\pm 0 \\\\\nfnearest_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q \\leq 0.5) \\\\\nfnearest_N(- q) &=& -0 & (\\mathrel{if} -0.5 \\leq -q < 0) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| < 0.5) \\\\\nfnearest_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} |i - q| = 0.5 \\wedge i~even) \\\\\n\\end{array}",
    "f64x2.neg": "The description of the operation fneg_N(z) is:\n\nIf z is a NaN, then return z with negated sign.\n\nElse if z is an infinity, then return that infinity negated.\n\nElse if z is a zero, then return that zero negated.\n\nElse return z negated.\n\n\\begin{array}{@lcll}\nfneg_N(\\pm nan(n)) &=& \\mp nan(n) \\\\\nfneg_N(\\pm \\infty) &=& \\mp \\infty \\\\\nfneg_N(\\pm 0) &=& \\mp 0 \\\\\nfneg_N(\\pm q) &=& \\mp q \\\\\n\\end{array}",
    "f64x2.pmax": "The description of the operation fmax_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if either z_1 or z_2 is a positive infinity, then return positive infinity.\n\nElse if either z_1 or z_2 is a negative infinity, then return the other value.\n\nElse if both z_1 and z_2 are zeroes of opposite signs, then return positive zero.\n\nElse return the larger value of z_1 and z_2.\n\n\\begin{array}{@lcll}\nfmax_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmax_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmax_N(+ \\infty, z_2) &=& + \\infty \\\\\nfmax_N(- \\infty, z_2) &=& z_2 \\\\\nfmax_N(z_1, + \\infty) &=& + \\infty \\\\\nfmax_N(z_1, - \\infty) &=& z_1 \\\\\nfmax_N(\\pm 0, \\mp 0) &=& +0 \\\\\nfmax_N(z_1, z_2) &=& z_1 & (\\mathrel{if} z_1 \\geq z_2) \\\\\nfmax_N(z_1, z_2) &=& z_2 & (\\mathrel{if} z_2 \\geq z_1) \\\\\n\\end{array}",
    "f64x2.pmin": "The description of the operation fpmin_N(z_1, z_2) is:\n\nIf z_2 is less than z_1 then return z_2.\n\nElse return z_1.\n\n\\begin{array}{@lcll}\nfpmin_N(z_1, z_2) &=& z_2 & (\\mathrel{if} flt_N(z_2, z_1) = 1) \\\\\nfpmin_N(z_1, z_2) &=& z_1 & (\\mathrel{otherwise})\n\\end{array}",
    "f64x2.promote_low_f32x4": "The description of the operation fmul_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if one of z_1 and z_2 is a zero and the other an infinity, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return positive infinity.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return negative infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with equal sign, then return positive infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with opposite sign, then return negative infinity.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return negative zero.\n\nElse return the result of multiplying z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfmul_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmul_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmul_N(\\pm \\infty, \\pm 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\mp 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm q_1, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm q_1, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfmul_N(\\pm 0, \\pm 0) &=& + 0 \\\\\nfmul_N(\\pm 0, \\mp 0) &=& - 0 \\\\\nfmul_N(z_1, z_2) &=& float_N(z_1 \\cdot z_2) \\\\\n\\end{array}",
    "f64x2.replace_lane": "The description of the operation fmul_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if one of z_1 and z_2 is a zero and the other an infinity, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of equal sign, then return positive infinity.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return negative infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with equal sign, then return positive infinity.\n\nElse if either z_1 or z_2 is an infinity and the other a value with opposite sign, then return negative infinity.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return negative zero.\n\nElse return the result of multiplying z_1 and z_2, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfmul_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfmul_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfmul_N(\\pm \\infty, \\pm 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\mp 0) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm 0, \\mp \\infty) &=& nans_N\\{\\} \\\\\nfmul_N(\\pm \\infty, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm q_1, \\pm \\infty) &=& +\\infty \\\\\nfmul_N(\\pm q_1, \\mp \\infty) &=& -\\infty \\\\\nfmul_N(\\pm \\infty, \\pm q_2) &=& +\\infty \\\\\nfmul_N(\\pm \\infty, \\mp q_2) &=& -\\infty \\\\\nfmul_N(\\pm 0, \\pm 0) &=& + 0 \\\\\nfmul_N(\\pm 0, \\mp 0) &=& - 0 \\\\\nfmul_N(z_1, z_2) &=& float_N(z_1 \\cdot z_2) \\\\\n\\end{array}",
    "f64x2.splat": "The description of the operation fsqrt_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is negative infinity, then return an element of nans_N\\{\\}.\n\nElse if z is positive infinity, then return positive infinity.\n\nElse if z is a zero, then return that zero.\n\nElse if z has a negative sign, then return an element of nans_N\\{\\}.\n\nElse return the square root of z.\n\n\\begin{array}{@lcll}\nfsqrt_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfsqrt_N(- \\infty) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ \\infty) &=& + \\infty \\\\\nfsqrt_N(\\pm 0) &=& \\pm 0 \\\\\nfsqrt_N(- q) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ q) &=& float_N\\left(\\sqrt{q}\\right) \\\\\n\\end{array}",
    "f64x2.sqrt": "The description of the operation fsqrt_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is negative infinity, then return an element of nans_N\\{\\}.\n\nElse if z is positive infinity, then return positive infinity.\n\nElse if z is a zero, then return that zero.\n\nElse if z has a negative sign, then return an element of nans_N\\{\\}.\n\nElse return the square root of z.\n\n\\begin{array}{@lcll}\nfsqrt_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nfsqrt_N(- \\infty) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ \\infty) &=& + \\infty \\\\\nfsqrt_N(\\pm 0) &=& \\pm 0 \\\\\nfsqrt_N(- q) &=& nans_N\\{\\} \\\\\nfsqrt_N(+ q) &=& float_N\\left(\\sqrt{q}\\right) \\\\\n\\end{array}",
    "f64x2.sub": "The description of the operation fsub_N(z_1, z_2) is:\n\nIf either z_1 or z_2 is a NaN, then return an element of nans_N\\{z_1, z_2\\}.\n\nElse if both z_1 and z_2 are infinities of equal signs, then return an element of nans_N\\{\\}.\n\nElse if both z_1 and z_2 are infinities of opposite sign, then return z_1.\n\nElse if z_1 is an infinity, then return that infinity.\n\nElse if z_2 is an infinity, then return that infinity negated.\n\nElse if both z_1 and z_2 are zeroes of equal sign, then return positive zero.\n\nElse if both z_1 and z_2 are zeroes of opposite sign, then return z_1.\n\nElse if z_2 is a zero, then return z_1.\n\nElse if z_1 is a zero, then return z_2 negated.\n\nElse if both z_1 and z_2 are the same value, then return positive zero.\n\nElse return the result of subtracting z_2 from z_1, rounded to the nearest representable value.\n\n\\begin{array}{@lcll}\nfsub_N(\\pm nan(n), z_2) &=& nans_N\\{\\pm nan(n), z_2\\} \\\\\nfsub_N(z_1, \\pm nan(n)) &=& nans_N\\{\\pm nan(n), z_1\\} \\\\\nfsub_N(\\pm \\infty, \\pm \\infty) &=& nans_N\\{\\} \\\\\nfsub_N(\\pm \\infty, \\mp \\infty) &=& \\pm \\infty \\\\\nfsub_N(z_1, \\pm \\infty) &=& \\mp \\infty \\\\\nfsub_N(\\pm \\infty, z_2) &=& \\pm \\infty \\\\\nfsub_N(\\pm 0, \\pm 0) &=& +0 \\\\\nfsub_N(\\pm 0, \\mp 0) &=& \\pm 0 \\\\\nfsub_N(z_1, \\pm 0) &=& z_1 \\\\\nfsub_N(\\pm 0, \\pm q_2) &=& \\mp q_2 \\\\\nfsub_N(\\pm q, \\pm q) &=& +0 \\\\\nfsub_N(z_1, z_2) &=& float_N(z_1 - z_2) \\\\\n\\end{array}\n\n\n\nUp to the non-determinism regarding NaNs, it always holds that fsub_N(z_1, z_2) = fadd_N(z_1, fneg_N(z_2)).",
    "f64x2.trunc": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i16x8.abs": "The description of the operation iabs_N(i) is:\n\nLet j be the signed interpretation of i.\n\nIf j is greater than or equal to 0, then return i.\n\nElse return the negation of j, modulo 2^N.\n\n\\begin{array}{@lcll}\niabs_N(i) &=& i & (\\mathrel{if} signed_N(i) \\ge 0) \\\\\niabs_N(i) &=& -signed_N(i) \\mathbin{mod} 2^N & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "i16x8.add": "The description of the operation iadd_N(i_1, i_2) is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i16x8.add_sat_s": "The description of the operation iaddsat\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1\n\nLet j_2 be the signed interpretation of i_2\n\nLet j be the result of adding j_1 and j_2.\n\nReturn sat^{s}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\niaddsat\\_s_N(i_1, i_2) &=& sat^{s}_N(signed_N(i_1) + signed_N(i_2))\n\\end{array}",
    "i16x8.add_sat_u": "The description of the operation iaddsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of adding i_1 and i_2.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\niaddsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 + i_2)\n\\end{array}",
    "i16x8.all_true": "The description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "i16x8.avgr_u": "The description of the operation iavgr\\_u_N(i_1, i_2) is:\n\nLet j be the result of adding i_1, i_2, and 1.\n\nReturn the result of dividing j by 2, truncated toward zero.\n\n\\begin{array}{lll@{\\qquad}l}\niavgr\\_u_N(i_1, i_2) &=& trunc((i_1 + i_2 + 1) / 2)\n\\end{array}",
    "i16x8.bitmask": "The description of the operation ilt\\_s is:\n\nReturn i_1 if ilt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_s_N(i_1, i_2) = 1)\\\\\nimin\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.eq": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ieqz_N(i) is:\n\nReturn 1 if i is zero, 0 otherwise.\n\n\\begin{array}{@lcll}\nieqz_N(i) &=& bool(i = 0)\n\\end{array}",
    "i16x8.extadd_pairwise_i8x16_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iadd is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.extadd_pairwise_i8x16_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iadd is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.extend_high_i8x16_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i16x8.extend_high_i8x16_u": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i16x8.extend_low_i8x16_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i16x8.extend_low_i8x16_u": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i16x8.extmul_high_i8x16_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.extmul_high_i8x16_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.extmul_low_i8x16_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.extmul_low_i8x16_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.extract_lane_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.extract_lane_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i16x8.ge_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.ge_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ige\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_u_N(i_1, i_2) &=& bool(i_1 \\geq i_2)\n\\end{array}",
    "i16x8.gt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) > signed_N(i_2))\n\\end{array}",
    "i16x8.gt_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_u_N(i_1, i_2) &=& bool(i_1 > i_2)\n\\end{array}",
    "i16x8.le_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.le_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i16x8.lt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ilt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is less than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) < signed_N(i_2))\n\\end{array}",
    "i16x8.lt_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ilt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_u_N(i_1, i_2) &=& bool(i_1 < i_2)\n\\end{array}",
    "i16x8.max_s": "The description of the operation imax\\_s_N(i_1, i_2) is:\n\nReturn i_1 if igt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimax\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} igt\\_s_N(i_1, i_2) = 1)\\\\\nimax\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i16x8.max_u": "The description of the operation imax\\_u_N(i_1, i_2) is:\n\nReturn i_1 if igt\\_u_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimax\\_u_N(i_1, i_2) &=& i_1 & (\\mathrel{if} igt\\_u_N(i_1, i_2) = 1)\\\\\nimax\\_u_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i16x8.min_s": "The description of the operation imin\\_s_N(i_1, i_2) is:\n\nReturn i_1 if ilt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_s_N(i_1, i_2) = 1)\\\\\nimin\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i16x8.min_u": "The description of the operation imin\\_u_N(i_1, i_2) is:\n\nReturn i_1 if ilt\\_u_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_u_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_u_N(i_1, i_2) = 1)\\\\\nimin\\_u_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i16x8.mul": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.narrow_i32x4_s": "The description of the operation narrow is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{u}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{u}_{M,N}(i) &=& sat^{u}_N(signed_M(i))\n\\end{array}\n\n\nThe description of the operation narrow^{s}_{M,N}(i) is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{s}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{s}_{M,N}(i) &=& sat^{s}_N(signed_M(i))\n\\end{array}",
    "i16x8.narrow_i32x4_u": "The description of the operation narrow is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{u}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{u}_{M,N}(i) &=& sat^{u}_N(signed_M(i))\n\\end{array}\n\n\nThe description of the operation narrow^{u}_{M,N}(i) is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{u}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{u}_{M,N}(i) &=& sat^{u}_N(signed_M(i))\n\\end{array}",
    "i16x8.ne": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ineg_N(i) is:\n\nReturn the result of negating i, modulo 2^N.\n\n\\begin{array}{@lcll}\nineg_N(i) &=& (2^N - i) \\mathbin{mod} 2^N\n\\end{array}",
    "i16x8.neg": "The description of the operation ineg_N(i) is:\n\nReturn the result of negating i, modulo 2^N.\n\n\\begin{array}{@lcll}\nineg_N(i) &=& (2^N - i) \\mathbin{mod} 2^N\n\\end{array}",
    "i16x8.q15mulr_sat_s": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.replace_lane": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.shl": "The description of the operation ishl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 left by k bits, modulo 2^N.\n\n\\begin{array}{@lcll}\nishl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~0^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i16x8.shr_s": "The description of the operation ishr\\_s_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with the most significant bit of the original value.\n\n\\begin{array}{@lcll}\nishr\\_s_N(i_1, i_2) &=& ibits_N^{-1}(d_0^{k+1}~d_1^{N-k-1})\n  & (\\mathrel{if} ibits_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i16x8.shr_u": "The description of the operation ishr\\_u_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with 0 bits.\n\n\\begin{array}{@lcll}\nishr\\_u_N(i_1, i_2) &=& ibits_N^{-1}(0^k~d_1^{N-k})\n  & (\\mathrel{if} ibits_N(i_1) = d_1^{N-k}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i16x8.splat": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i16x8.sub": "The description of the operation isubsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of subtracting i_2 from i_1.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 - i_2)\n\\end{array}",
    "i16x8.sub_sat_s": "The description of the operation isubsat\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1\n\nLet j_2 be the signed interpretation of i_2\n\nLet j be the result of subtracting j_2 from j_1.\n\nReturn sat^{s}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_s_N(i_1, i_2) &=& sat^{s}_N(signed_N(i_1) - signed_N(i_2))\n\\end{array}",
    "i16x8.sub_sat_u": "The description of the operation isubsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of subtracting i_2 from i_1.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 - i_2)\n\\end{array}",
    "i32.add": "The description of the operation iadd_N(i_1, i_2) is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i32.and": "The description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "i32.clz": "The description of the operation iclz_N(i) is:\n\nReturn the count of leading zero bits in i; all bits are considered leading zeros if i is 0.\n\n\\begin{array}{@lcll}\niclz_N(i) &=& k & (\\mathrel{if} ibits_N(i) = 0^k~(1~d^\\ast)^?)\n\\end{array}",
    "i32.ctz": "The description of the operation ictz_N(i) is:\n\nReturn the count of trailing zero bits in i; all bits are considered trailing zeros if i is 0.\n\n\\begin{array}{@lcll}\nictz_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (d^\\ast~1)^?~0^k)\n\\end{array}",
    "i32.div_s": "The description of the operation idiv\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nIf j_2 is 0, then the result is undefined.\n\nElse if j_1 divided by j_2 is 2^{N-1}, then the result is undefined.\n\nElse, return the result of dividing j_1 by j_2, truncated toward zero.\n\n\\begin{array}{@lcll}\nidiv\\_s_N(i_1, 0) &=& \\{\\} \\\\\nidiv\\_s_N(i_1, i_2) &=& \\{\\} \\qquad\\qquad (\\mathrel{if} signed_N(i_1) / signed_N(i_2) = 2^{N-1}) \\\\\nidiv\\_s_N(i_1, i_2) &=& signed_N^{-1}(trunc(signed_N(i_1) / signed_N(i_2))) \\\\\n\\end{array}\n\n\n\nThis operator is partial.\nBesides division by 0, the result of (-2^{N-1})/(-1) = +2^{N-1} is not representable as an N-bit signed integer.",
    "i32.div_u": "The description of the operation idiv\\_u_N(i_1, i_2) is:\n\nIf i_2 is 0, then the result is undefined.\n\nElse, return the result of dividing i_1 by i_2, truncated toward zero.\n\n\\begin{array}{@lcll}\nidiv\\_u_N(i_1, 0) &=& \\{\\} \\\\\nidiv\\_u_N(i_1, i_2) &=& trunc(i_1 / i_2) \\\\\n\\end{array}\n\n\n\nThis operator is partial.",
    "i32.eq": "The description of the operation ieq_N(i_1, i_2) is:\n\nReturn 1 if i_1 equals i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nieq_N(i_1, i_2) &=& bool(i_1 = i_2)\n\\end{array}",
    "i32.eqz": "The description of the operation ieqz_N(i) is:\n\nReturn 1 if i is zero, 0 otherwise.\n\n\\begin{array}{@lcll}\nieqz_N(i) &=& bool(i = 0)\n\\end{array}",
    "i32.extend16_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i32.extend8_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i32.ge_s": "The description of the operation ige\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than or equal to j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) \\geq signed_N(i_2))\n\\end{array}",
    "i32.ge_u": "The description of the operation ige\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_u_N(i_1, i_2) &=& bool(i_1 \\geq i_2)\n\\end{array}",
    "i32.gt_s": "The description of the operation igt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) > signed_N(i_2))\n\\end{array}",
    "i32.gt_u": "The description of the operation igt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_u_N(i_1, i_2) &=& bool(i_1 > i_2)\n\\end{array}",
    "i32.le_s": "The description of the operation ile\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is less than or equal to j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) \\leq signed_N(i_2))\n\\end{array}",
    "i32.le_u": "The description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i32.load": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i32.load16_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32.load16_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i32.load8_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "i32.load8_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i32.lt_s": "The description of the operation ilt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is less than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) < signed_N(i_2))\n\\end{array}",
    "i32.lt_u": "The description of the operation ilt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_u_N(i_1, i_2) &=& bool(i_1 < i_2)\n\\end{array}",
    "i32.mul": "The description of the operation imul_N(i_1, i_2) is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i32.ne": "The description of the operation ineg_N(i) is:\n\nReturn the result of negating i, modulo 2^N.\n\n\\begin{array}{@lcll}\nineg_N(i) &=& (2^N - i) \\mathbin{mod} 2^N\n\\end{array}",
    "i32.or": "The description of the operation ior_N(i_1, i_2) is:\n\nReturn the bitwise disjunction of i_1 and i_2.\n\n\\begin{array}{@lcll}\nior_N(i_1, i_2) &=& ibits_N^{-1}(ibits_N(i_1) \\vee ibits_N(i_2))\n\\end{array}",
    "i32.popcnt": "The description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "i32.reinterpret_f32": "The description of the operation reinterpret_{t_1,t_2}(c) is:\n\nLet d^\\ast be the bit sequence bits_{t_1}(c).\n\nReturn the constant c' for which bits_{t_2}(c') = d^\\ast.\n\n\\begin{array}{lll@{\\qquad}l}\nreinterpret_{t_1,t_2}(c) &=& bits_{t_2}^{-1}(bits_{t_1}(c)) \\\\\n\\end{array}",
    "i32.rem_s": "The description of the operation irem\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nIf i_2 is 0, then the result is undefined.\n\nElse, return the remainder of dividing j_1 by j_2, with the sign of the dividend j_1.\n\n\\begin{array}{@lcll}\nirem\\_s_N(i_1, 0) &=& \\{\\} \\\\\nirem\\_s_N(i_1, i_2) &=& signed_N^{-1}(j_1 - j_2 \\cdot trunc(j_1 / j_2)) \\\\\n  && (\\mathrel{where} j_1 = signed_N(i_1) \\wedge j_2 = signed_N(i_2)) \\\\\n\\end{array}\n\n\n\nThis operator is partial.\n\nAs long as both operators are defined,\nit holds that i_1 = i_2\\cdotidiv\\_s(i_1, i_2) + irem\\_s(i_1, i_2).",
    "i32.rem_u": "The description of the operation irem\\_u_N(i_1, i_2) is:\n\nIf i_2 is 0, then the result is undefined.\n\nElse, return the remainder of dividing i_1 by i_2.\n\n\\begin{array}{@lcll}\nirem\\_u_N(i_1, 0) &=& \\{\\} \\\\\nirem\\_u_N(i_1, i_2) &=& i_1 - i_2 \\cdot trunc(i_1 / i_2) \\\\\n\\end{array}\n\n\n\nThis operator is partial.\n\nAs long as both operators are defined,\nit holds that i_1 = i_2\\cdotidiv\\_u(i_1, i_2) + irem\\_u(i_1, i_2).",
    "i32.rotl": "The description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32.rotr": "The description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32.shl": "The description of the operation ishl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 left by k bits, modulo 2^N.\n\n\\begin{array}{@lcll}\nishl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~0^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32.shr_s": "The description of the operation ishr\\_s_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with the most significant bit of the original value.\n\n\\begin{array}{@lcll}\nishr\\_s_N(i_1, i_2) &=& ibits_N^{-1}(d_0^{k+1}~d_1^{N-k-1})\n  & (\\mathrel{if} ibits_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32.shr_u": "The description of the operation ishr\\_u_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with 0 bits.\n\n\\begin{array}{@lcll}\nishr\\_u_N(i_1, i_2) &=& ibits_N^{-1}(0^k~d_1^{N-k})\n  & (\\mathrel{if} ibits_N(i_1) = d_1^{N-k}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32.store": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i32.store16": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32.store8": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "i32.sub": "The description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i32.trunc_f32_s": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i32.trunc_f32_u": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i32.trunc_f64_s": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i32.trunc_f64_u": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i32.trunc_sat_f32_s": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i32.trunc_sat_f32_u": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i32.trunc_sat_f64_s": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i32.trunc_sat_f64_u": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i32.wrap_i64": "The description of the operation wrap_{M,N}(i) is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}",
    "i32.xor": "The description of the operation ixor_N(i_1, i_2) is:\n\nReturn the bitwise exclusive disjunction of i_1 and i_2.\n\n\\begin{array}{@lcll}\nixor_N(i_1, i_2) &=& ibits_N^{-1}(ibits_N(i_1) \\veebar ibits_N(i_2))\n\\end{array}",
    "i32x4.abs": "The description of the operation iabs_N(i) is:\n\nLet j be the signed interpretation of i.\n\nIf j is greater than or equal to 0, then return i.\n\nElse return the negation of j, modulo 2^N.\n\n\\begin{array}{@lcll}\niabs_N(i) &=& i & (\\mathrel{if} signed_N(i) \\ge 0) \\\\\niabs_N(i) &=& -signed_N(i) \\mathbin{mod} 2^N & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "i32x4.add": "The description of the operation iadd_N(i_1, i_2) is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i32x4.all_true": "The description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "i32x4.bitmask": "The description of the operation ilt\\_s is:\n\nReturn i_1 if ilt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_s_N(i_1, i_2) = 1)\\\\\nimin\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}\n\n\nThe description of the operation ibitselect_N(i_1, i_2, i_3) is:\n\nLet j_1 be the bitwise conjunction of i_1 and i_3.\n\nLet j_3' be the bitwise negation of i_3.\n\nLet j_2 be the bitwise conjunction of i_2 and j_3'.\n\nReturn the bitwise disjunction of j_1 and j_2.\n\n\\begin{array}{@lcll}\nibitselect_N(i_1, i_2, i_3) &=& ior_N(iand_N(i_1, i_3), iand_N(i_2, inot_N(i_3)))\n\\end{array}",
    "i32x4.dot_i16x8_s": "The description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iadd is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.eq": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ieqz_N(i) is:\n\nReturn 1 if i is zero, 0 otherwise.\n\n\\begin{array}{@lcll}\nieqz_N(i) &=& bool(i = 0)\n\\end{array}",
    "i32x4.extadd_pairwise_i16x8_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iadd is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.extadd_pairwise_i16x8_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iadd is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.extend_high_i16x8_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i32x4.extend_high_i16x8_u": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i32x4.extend_low_i16x8_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i32x4.extend_low_i16x8_u": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i32x4.extmul_high_i16x8_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.extmul_high_i16x8_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.extmul_low_i16x8_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.extmul_low_i16x8_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.extract_lane": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32x4.ge_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ige\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than or equal to j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) \\geq signed_N(i_2))\n\\end{array}",
    "i32x4.ge_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ige\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_u_N(i_1, i_2) &=& bool(i_1 \\geq i_2)\n\\end{array}",
    "i32x4.gt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) > signed_N(i_2))\n\\end{array}",
    "i32x4.gt_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_u_N(i_1, i_2) &=& bool(i_1 > i_2)\n\\end{array}",
    "i32x4.le_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.le_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i32x4.lt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ilt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is less than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) < signed_N(i_2))\n\\end{array}",
    "i32x4.lt_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ilt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_u_N(i_1, i_2) &=& bool(i_1 < i_2)\n\\end{array}",
    "i32x4.max_s": "The description of the operation imax\\_s_N(i_1, i_2) is:\n\nReturn i_1 if igt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimax\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} igt\\_s_N(i_1, i_2) = 1)\\\\\nimax\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i32x4.max_u": "The description of the operation imax\\_u_N(i_1, i_2) is:\n\nReturn i_1 if igt\\_u_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimax\\_u_N(i_1, i_2) &=& i_1 & (\\mathrel{if} igt\\_u_N(i_1, i_2) = 1)\\\\\nimax\\_u_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i32x4.min_s": "The description of the operation imin\\_s_N(i_1, i_2) is:\n\nReturn i_1 if ilt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_s_N(i_1, i_2) = 1)\\\\\nimin\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i32x4.min_u": "The description of the operation imin\\_u_N(i_1, i_2) is:\n\nReturn i_1 if ilt\\_u_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_u_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_u_N(i_1, i_2) = 1)\\\\\nimin\\_u_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i32x4.mul": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.ne": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_u_N(i_1, i_2) &=& bool(i_1 > i_2)\n\\end{array}",
    "i32x4.neg": "The description of the operation ineg_N(i) is:\n\nReturn the result of negating i, modulo 2^N.\n\n\\begin{array}{@lcll}\nineg_N(i) &=& (2^N - i) \\mathbin{mod} 2^N\n\\end{array}",
    "i32x4.replace_lane": "The description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32x4.shl": "The description of the operation ishl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 left by k bits, modulo 2^N.\n\n\\begin{array}{@lcll}\nishl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~0^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32x4.shr_s": "The description of the operation ishr\\_s_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with the most significant bit of the original value.\n\n\\begin{array}{@lcll}\nishr\\_s_N(i_1, i_2) &=& ibits_N^{-1}(d_0^{k+1}~d_1^{N-k-1})\n  & (\\mathrel{if} ibits_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32x4.shr_u": "The description of the operation ishr\\_u_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with 0 bits.\n\n\\begin{array}{@lcll}\nishr\\_u_N(i_1, i_2) &=& ibits_N^{-1}(0^k~d_1^{N-k})\n  & (\\mathrel{if} ibits_N(i_1) = d_1^{N-k}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i32x4.splat": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i32x4.sub": "The description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i32x4.trunc_sat_f32x4_s": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i32x4.trunc_sat_f32x4_u": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i32x4.trunc_sat_f64x2_s_zero": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i32x4.trunc_sat_f64x2_u_zero": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i64.add": "The description of the operation iadd_N(i_1, i_2) is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i64.and": "The description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "i64.clz": "The description of the operation iclz_N(i) is:\n\nReturn the count of leading zero bits in i; all bits are considered leading zeros if i is 0.\n\n\\begin{array}{@lcll}\niclz_N(i) &=& k & (\\mathrel{if} ibits_N(i) = 0^k~(1~d^\\ast)^?)\n\\end{array}",
    "i64.ctz": "The description of the operation ictz_N(i) is:\n\nReturn the count of trailing zero bits in i; all bits are considered trailing zeros if i is 0.\n\n\\begin{array}{@lcll}\nictz_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (d^\\ast~1)^?~0^k)\n\\end{array}",
    "i64.div_s": "The description of the operation idiv\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nIf j_2 is 0, then the result is undefined.\n\nElse if j_1 divided by j_2 is 2^{N-1}, then the result is undefined.\n\nElse, return the result of dividing j_1 by j_2, truncated toward zero.\n\n\\begin{array}{@lcll}\nidiv\\_s_N(i_1, 0) &=& \\{\\} \\\\\nidiv\\_s_N(i_1, i_2) &=& \\{\\} \\qquad\\qquad (\\mathrel{if} signed_N(i_1) / signed_N(i_2) = 2^{N-1}) \\\\\nidiv\\_s_N(i_1, i_2) &=& signed_N^{-1}(trunc(signed_N(i_1) / signed_N(i_2))) \\\\\n\\end{array}\n\n\n\nThis operator is partial.\nBesides division by 0, the result of (-2^{N-1})/(-1) = +2^{N-1} is not representable as an N-bit signed integer.",
    "i64.div_u": "The description of the operation idiv\\_u_N(i_1, i_2) is:\n\nIf i_2 is 0, then the result is undefined.\n\nElse, return the result of dividing i_1 by i_2, truncated toward zero.\n\n\\begin{array}{@lcll}\nidiv\\_u_N(i_1, 0) &=& \\{\\} \\\\\nidiv\\_u_N(i_1, i_2) &=& trunc(i_1 / i_2) \\\\\n\\end{array}\n\n\n\nThis operator is partial.",
    "i64.eq": "The description of the operation ieq_N(i_1, i_2) is:\n\nReturn 1 if i_1 equals i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nieq_N(i_1, i_2) &=& bool(i_1 = i_2)\n\\end{array}",
    "i64.eqz": "The description of the operation ieqz_N(i) is:\n\nReturn 1 if i is zero, 0 otherwise.\n\n\\begin{array}{@lcll}\nieqz_N(i) &=& bool(i = 0)\n\\end{array}",
    "i64.extend16_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64.extend32_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64.extend8_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64.extend_i32_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64.extend_i32_u": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64.ge_s": "The description of the operation ige\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than or equal to j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) \\geq signed_N(i_2))\n\\end{array}",
    "i64.ge_u": "The description of the operation ige\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_u_N(i_1, i_2) &=& bool(i_1 \\geq i_2)\n\\end{array}",
    "i64.gt_s": "The description of the operation igt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) > signed_N(i_2))\n\\end{array}",
    "i64.gt_u": "The description of the operation igt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_u_N(i_1, i_2) &=& bool(i_1 > i_2)\n\\end{array}",
    "i64.le_s": "The description of the operation ishl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 left by k bits, modulo 2^N.\n\n\\begin{array}{@lcll}\nishl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~0^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64.le_u": "The description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i64.load": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i64.load16_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64.load16_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i64.load32_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i64.load32_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i64.load8_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "i64.load8_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i64.lt_s": "The description of the operation ilt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is less than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) < signed_N(i_2))\n\\end{array}",
    "i64.lt_u": "The description of the operation ilt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_u_N(i_1, i_2) &=& bool(i_1 < i_2)\n\\end{array}",
    "i64.mul": "The description of the operation imul_N(i_1, i_2) is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i64.ne": "The description of the operation inot_N(i) is:\n\nReturn the bitwise negation of i.\n\n\\begin{array}{@lcll}\ninot_N(i) &=& ibits_N^{-1}(ibits_N(i) \\veebar ibits_N(2^N-1))\n\\end{array}",
    "i64.or": "The description of the operation ior_N(i_1, i_2) is:\n\nReturn the bitwise disjunction of i_1 and i_2.\n\n\\begin{array}{@lcll}\nior_N(i_1, i_2) &=& ibits_N^{-1}(ibits_N(i_1) \\vee ibits_N(i_2))\n\\end{array}",
    "i64.popcnt": "The description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "i64.reinterpret_f64": "The description of the operation reinterpret_{t_1,t_2}(c) is:\n\nLet d^\\ast be the bit sequence bits_{t_1}(c).\n\nReturn the constant c' for which bits_{t_2}(c') = d^\\ast.\n\n\\begin{array}{lll@{\\qquad}l}\nreinterpret_{t_1,t_2}(c) &=& bits_{t_2}^{-1}(bits_{t_1}(c)) \\\\\n\\end{array}",
    "i64.rem_s": "The description of the operation irem\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nIf i_2 is 0, then the result is undefined.\n\nElse, return the remainder of dividing j_1 by j_2, with the sign of the dividend j_1.\n\n\\begin{array}{@lcll}\nirem\\_s_N(i_1, 0) &=& \\{\\} \\\\\nirem\\_s_N(i_1, i_2) &=& signed_N^{-1}(j_1 - j_2 \\cdot trunc(j_1 / j_2)) \\\\\n  && (\\mathrel{where} j_1 = signed_N(i_1) \\wedge j_2 = signed_N(i_2)) \\\\\n\\end{array}\n\n\n\nThis operator is partial.\n\nAs long as both operators are defined,\nit holds that i_1 = i_2\\cdotidiv\\_s(i_1, i_2) + irem\\_s(i_1, i_2).",
    "i64.rem_u": "The description of the operation irem\\_u_N(i_1, i_2) is:\n\nIf i_2 is 0, then the result is undefined.\n\nElse, return the remainder of dividing i_1 by i_2.\n\n\\begin{array}{@lcll}\nirem\\_u_N(i_1, 0) &=& \\{\\} \\\\\nirem\\_u_N(i_1, i_2) &=& i_1 - i_2 \\cdot trunc(i_1 / i_2) \\\\\n\\end{array}\n\n\n\nThis operator is partial.\n\nAs long as both operators are defined,\nit holds that i_1 = i_2\\cdotidiv\\_u(i_1, i_2) + irem\\_u(i_1, i_2).",
    "i64.rotl": "The description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64.rotr": "The description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64.shl": "The description of the operation ishl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 left by k bits, modulo 2^N.\n\n\\begin{array}{@lcll}\nishl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~0^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64.shr_s": "The description of the operation ishr\\_s_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with the most significant bit of the original value.\n\n\\begin{array}{@lcll}\nishr\\_s_N(i_1, i_2) &=& ibits_N^{-1}(d_0^{k+1}~d_1^{N-k-1})\n  & (\\mathrel{if} ibits_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64.shr_u": "The description of the operation ishr\\_u_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with 0 bits.\n\n\\begin{array}{@lcll}\nishr\\_u_N(i_1, i_2) &=& ibits_N^{-1}(0^k~d_1^{N-k})\n  & (\\mathrel{if} ibits_N(i_1) = d_1^{N-k}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64.store": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i64.store16": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64.store32": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64.store8": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "i64.sub": "The description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i64.trunc_f32_s": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i64.trunc_f32_u": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i64.trunc_f64_s": "The description of the operation ftrunc_N(z) is:\n\nIf z is a NaN, then return an element of nans_N\\{z\\}.\n\nElse if z is an infinity, then return z.\n\nElse if z is a zero, then return z.\n\nElse if z is greater than 0 but smaller than 1, then return positive zero.\n\nElse if z is smaller than 0 but greater than -1, then return negative zero.\n\nElse return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.\n\n\\begin{array}{@lcll}\nftrunc_N(\\pm nan(n)) &=& nans_N\\{\\pm nan(n)\\} \\\\\nftrunc_N(\\pm \\infty) &=& \\pm \\infty \\\\\nftrunc_N(\\pm 0) &=& \\pm 0 \\\\\nftrunc_N(+ q) &=& +0 & (\\mathrel{if} 0 < +q < 1) \\\\\nftrunc_N(- q) &=& -0 & (\\mathrel{if} -1 < -q < 0) \\\\\nftrunc_N(\\pm q) &=& float_N(\\pm i) & (\\mathrel{if} +q - 1 < i \\leq +q) \\\\\n\\end{array}",
    "i64.trunc_f64_u": "The description of the operation trunc^{u}_{M,N}(z) is:\n\nIf z is a NaN, then the result is undefined.\n\nElse if z is an infinity, then the result is undefined.\n\nElse if z is a number and trunc(z) is a value within range of the target type, then return that value.\n\nElse the result is undefined.\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc^{u}_{M,N}(\\pm nan(n)) &=& \\{\\} \\\\\ntrunc^{u}_{M,N}(\\pm \\infty) &=& \\{\\} \\\\\ntrunc^{u}_{M,N}(\\pm q) &=& trunc(\\pm q) & (\\mathrel{if} -1 < trunc(\\pm q) < 2^N) \\\\\ntrunc^{u}_{M,N}(\\pm q) &=& \\{\\} & (\\mathrel{otherwise}) \\\\\n\\end{array}\n\n\n\nThis operator is partial.\nIt is not defined for NaNs, infinities, or values for which the result is out of range.",
    "i64.trunc_sat_f32_s": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i64.trunc_sat_f32_u": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i64.trunc_sat_f64_s": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i64.trunc_sat_f64_u": "The description of the operation trunc\\_sat\\_u_{M,N}(z) is:\n\nIf z is a NaN, then return 0.\n\nElse if z is negative infinity, then return 0.\n\nElse if z is positive infinity, then return 2^N - 1.\n\nElse, return sat^{u}_N(trunc(z)).\n\n\\begin{array}{lll@{\\qquad}l}\ntrunc\\_sat\\_u_{M,N}(\\pm nan(n)) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(- \\infty) &=& 0 \\\\\ntrunc\\_sat\\_u_{M,N}(+ \\infty) &=& 2^N - 1 \\\\\ntrunc\\_sat\\_u_{M,N}(z) &=& sat^{u}_N(trunc(z)) \\\\\n\\end{array}",
    "i64.xor": "The description of the operation ixor_N(i_1, i_2) is:\n\nReturn the bitwise exclusive disjunction of i_1 and i_2.\n\n\\begin{array}{@lcll}\nixor_N(i_1, i_2) &=& ibits_N^{-1}(ibits_N(i_1) \\veebar ibits_N(i_2))\n\\end{array}",
    "i64x2.abs": "The description of the operation iabs_N(i) is:\n\nLet j be the signed interpretation of i.\n\nIf j is greater than or equal to 0, then return i.\n\nElse return the negation of j, modulo 2^N.\n\n\\begin{array}{@lcll}\niabs_N(i) &=& i & (\\mathrel{if} signed_N(i) \\ge 0) \\\\\niabs_N(i) &=& -signed_N(i) \\mathbin{mod} 2^N & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "i64x2.add": "The description of the operation iadd_N(i_1, i_2) is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i64x2.all_true": "The description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "i64x2.bitmask": "The description of the operation ilt\\_s is:\n\nReturn i_1 if ilt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_s_N(i_1, i_2) = 1)\\\\\nimin\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}\n\n\nThe description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "i64x2.eq": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ieq_N(i_1, i_2) is:\n\nReturn 1 if i_1 equals i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nieq_N(i_1, i_2) &=& bool(i_1 = i_2)\n\\end{array}",
    "i64x2.extend_high_i32x4_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64x2.extend_high_i32x4_u": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64x2.extend_low_i32x4_s": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64x2.extend_low_i32x4_u": "The description of the operation iextendM\\_s_N(i) is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}",
    "i64x2.extmul_high_i32x4_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64x2.extmul_high_i32x4_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64x2.extmul_low_i32x4_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64x2.extmul_low_i32x4_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation imul is:\n\nReturn the result of multiplying i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\nimul_N(i_1, i_2) &=& (i_1 \\cdot i_2) \\mathbin{mod} 2^N\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64x2.extract_lane": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation irotl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of rotating i_1 left by k bits.\n\n\\begin{array}{@lcll}\nirotl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~d_1^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64x2.ge_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ige\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than or equal to j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) \\geq signed_N(i_2))\n\\end{array}",
    "i64x2.gt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) > signed_N(i_2))\n\\end{array}",
    "i64x2.le_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64x2.lt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ilt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is less than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) < signed_N(i_2))\n\\end{array}",
    "i64x2.mul": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64x2.ne": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_u_N(i_1, i_2) &=& bool(i_1 > i_2)\n\\end{array}",
    "i64x2.neg": "The description of the operation ineg_N(i) is:\n\nReturn the result of negating i, modulo 2^N.\n\n\\begin{array}{@lcll}\nineg_N(i) &=& (2^N - i) \\mathbin{mod} 2^N\n\\end{array}",
    "i64x2.replace_lane": "The description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i64x2.shl": "The description of the operation ishl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 left by k bits, modulo 2^N.\n\n\\begin{array}{@lcll}\nishl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~0^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64x2.shr_s": "The description of the operation ishr\\_s_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with the most significant bit of the original value.\n\n\\begin{array}{@lcll}\nishr\\_s_N(i_1, i_2) &=& ibits_N^{-1}(d_0^{k+1}~d_1^{N-k-1})\n  & (\\mathrel{if} ibits_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64x2.shr_u": "The description of the operation ishr\\_u_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with 0 bits.\n\n\\begin{array}{@lcll}\nishr\\_u_N(i_1, i_2) &=& ibits_N^{-1}(0^k~d_1^{N-k})\n  & (\\mathrel{if} ibits_N(i_1) = d_1^{N-k}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i64x2.splat": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i64x2.sub": "The description of the operation isub_N(i_1, i_2) is:\n\nReturn the result of subtracting i_2 from i_1 modulo 2^N.\n\n\\begin{array}{@lcll}\nisub_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \\mathbin{mod} 2^N\n\\end{array}",
    "i8x16.abs": "The description of the operation iabs_N(i) is:\n\nLet j be the signed interpretation of i.\n\nIf j is greater than or equal to 0, then return i.\n\nElse return the negation of j, modulo 2^N.\n\n\\begin{array}{@lcll}\niabs_N(i) &=& i & (\\mathrel{if} signed_N(i) \\ge 0) \\\\\niabs_N(i) &=& -signed_N(i) \\mathbin{mod} 2^N & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "i8x16.add": "The description of the operation iadd_N(i_1, i_2) is:\n\nReturn the result of adding i_1 and i_2 modulo 2^N.\n\n\\begin{array}{@lcll}\niadd_N(i_1, i_2) &=& (i_1 + i_2) \\mathbin{mod} 2^N\n\\end{array}",
    "i8x16.add_sat_s": "The description of the operation iaddsat\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1\n\nLet j_2 be the signed interpretation of i_2\n\nLet j be the result of adding j_1 and j_2.\n\nReturn sat^{s}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\niaddsat\\_s_N(i_1, i_2) &=& sat^{s}_N(signed_N(i_1) + signed_N(i_2))\n\\end{array}",
    "i8x16.add_sat_u": "The description of the operation iaddsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of adding i_1 and i_2.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\niaddsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 + i_2)\n\\end{array}",
    "i8x16.all_true": "The description of the operation ieqz_N(i) is:\n\nReturn 1 if i is zero, 0 otherwise.\n\n\\begin{array}{@lcll}\nieqz_N(i) &=& bool(i = 0)\n\\end{array}",
    "i8x16.avgr_u": "The description of the operation iavgr\\_u_N(i_1, i_2) is:\n\nLet j be the result of adding i_1, i_2, and 1.\n\nReturn the result of dividing j by 2, truncated toward zero.\n\n\\begin{array}{lll@{\\qquad}l}\niavgr\\_u_N(i_1, i_2) &=& trunc((i_1 + i_2 + 1) / 2)\n\\end{array}",
    "i8x16.bitmask": "The description of the operation ilt\\_s is:\n\nReturn i_1 if ilt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_s_N(i_1, i_2) = 1)\\\\\nimin\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i8x16.eq": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ieqz_N(i) is:\n\nReturn 1 if i is zero, 0 otherwise.\n\n\\begin{array}{@lcll}\nieqz_N(i) &=& bool(i = 0)\n\\end{array}",
    "i8x16.extract_lane_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i8x16.extract_lane_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation extend^{u}_{M,N}(i) is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.",
    "i8x16.ge_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) > signed_N(i_2))\n\\end{array}",
    "i8x16.ge_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ige\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nige\\_u_N(i_1, i_2) &=& bool(i_1 \\geq i_2)\n\\end{array}",
    "i8x16.gt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is greater than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) > signed_N(i_2))\n\\end{array}",
    "i8x16.gt_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation igt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is greater than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nigt\\_u_N(i_1, i_2) &=& bool(i_1 > i_2)\n\\end{array}",
    "i8x16.le_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i8x16.le_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "i8x16.lt_s": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ilt\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1.\n\nLet j_2 be the signed interpretation of i_2.\n\nReturn 1 if j_1 is less than j_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_s_N(i_1, i_2) &=& bool(signed_N(i_1) < signed_N(i_2))\n\\end{array}",
    "i8x16.lt_u": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ilt\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nilt\\_u_N(i_1, i_2) &=& bool(i_1 < i_2)\n\\end{array}",
    "i8x16.max_s": "The description of the operation imax\\_s_N(i_1, i_2) is:\n\nReturn i_1 if igt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimax\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} igt\\_s_N(i_1, i_2) = 1)\\\\\nimax\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i8x16.max_u": "The description of the operation imax\\_u_N(i_1, i_2) is:\n\nReturn i_1 if igt\\_u_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimax\\_u_N(i_1, i_2) &=& i_1 & (\\mathrel{if} igt\\_u_N(i_1, i_2) = 1)\\\\\nimax\\_u_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i8x16.min_s": "The description of the operation imin\\_s_N(i_1, i_2) is:\n\nReturn i_1 if ilt\\_s_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_s_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_s_N(i_1, i_2) = 1)\\\\\nimin\\_s_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i8x16.min_u": "The description of the operation imin\\_u_N(i_1, i_2) is:\n\nReturn i_1 if ilt\\_u_N(i_1, i_2) is 1, return i_2 otherwise.\n\n\\begin{array}{@lcll}\nimin\\_u_N(i_1, i_2) &=& i_1 & (\\mathrel{if} ilt\\_u_N(i_1, i_2) = 1)\\\\\nimin\\_u_N(i_1, i_2) &=& i_2 & (\\mathrel{otherwise})\n\\end{array}",
    "i8x16.narrow_i16x8_s": "The description of the operation narrow is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{u}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{u}_{M,N}(i) &=& sat^{u}_N(signed_M(i))\n\\end{array}\n\n\nThe description of the operation narrow^{s}_{M,N}(i) is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{s}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{s}_{M,N}(i) &=& sat^{s}_N(signed_M(i))\n\\end{array}",
    "i8x16.narrow_i16x8_u": "The description of the operation narrow is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{u}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{u}_{M,N}(i) &=& sat^{u}_N(signed_M(i))\n\\end{array}\n\n\nThe description of the operation narrow^{u}_{M,N}(i) is:\n\nLet j be the signed interpretation of i of size M.\n\nReturn sat^{u}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nnarrow^{u}_{M,N}(i) &=& sat^{u}_N(signed_M(i))\n\\end{array}",
    "i8x16.ne": "The description of the operation extend^{s} is:\n\nReturn extend^{s}_{M,N}(i).\n\n\\begin{array}{lll@{\\qquad}l}\niextendM\\_s_{N}(i) &=& extend^{s}_{M,N}(i) \\\\\n\\end{array}\n\n\nThe description of the operation ieqz_N(i) is:\n\nReturn 1 if i is zero, 0 otherwise.\n\n\\begin{array}{@lcll}\nieqz_N(i) &=& bool(i = 0)\n\\end{array}",
    "i8x16.neg": "The description of the operation ineg_N(i) is:\n\nReturn the result of negating i, modulo 2^N.\n\n\\begin{array}{@lcll}\nineg_N(i) &=& (2^N - i) \\mathbin{mod} 2^N\n\\end{array}",
    "i8x16.popcnt": "The description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "i8x16.replace_lane": "The description of the operation iclz_N(i) is:\n\nReturn the count of leading zero bits in i; all bits are considered leading zeros if i is 0.\n\n\\begin{array}{@lcll}\niclz_N(i) &=& k & (\\mathrel{if} ibits_N(i) = 0^k~(1~d^\\ast)^?)\n\\end{array}",
    "i8x16.shl": "The description of the operation ishl_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 left by k bits, modulo 2^N.\n\n\\begin{array}{@lcll}\nishl_N(i_1, i_2) &=& ibits_N^{-1}(d_2^{N-k}~0^k)\n  & (\\mathrel{if} ibits_N(i_1) = d_1^k~d_2^{N-k} \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i8x16.shr_s": "The description of the operation ishr\\_s_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with the most significant bit of the original value.\n\n\\begin{array}{@lcll}\nishr\\_s_N(i_1, i_2) &=& ibits_N^{-1}(d_0^{k+1}~d_1^{N-k-1})\n  & (\\mathrel{if} ibits_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i8x16.shr_u": "The description of the operation ishr\\_u_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with 0 bits.\n\n\\begin{array}{@lcll}\nishr\\_u_N(i_1, i_2) &=& ibits_N^{-1}(0^k~d_1^{N-k})\n  & (\\mathrel{if} ibits_N(i_1) = d_1^{N-k}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i8x16.shuffle": "The description of the operation ishr\\_u_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with 0 bits.\n\n\\begin{array}{@lcll}\nishr\\_u_N(i_1, i_2) &=& ibits_N^{-1}(0^k~d_1^{N-k})\n  & (\\mathrel{if} ibits_N(i_1) = d_1^{N-k}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "i8x16.splat": "The description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "i8x16.sub": "The description of the operation isubsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of subtracting i_2 from i_1.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 - i_2)\n\\end{array}",
    "i8x16.sub_sat_s": "The description of the operation isubsat\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1\n\nLet j_2 be the signed interpretation of i_2\n\nLet j be the result of subtracting j_2 from j_1.\n\nReturn sat^{s}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_s_N(i_1, i_2) &=& sat^{s}_N(signed_N(i_1) - signed_N(i_2))\n\\end{array}",
    "i8x16.sub_sat_u": "The description of the operation isubsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of subtracting i_2 from i_1.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 - i_2)\n\\end{array}",
    "i8x16.swizzle": "The description of the operation iclz_N(i) is:\n\nReturn the count of leading zero bits in i; all bits are considered leading zeros if i is 0.\n\n\\begin{array}{@lcll}\niclz_N(i) &=& k & (\\mathrel{if} ibits_N(i) = 0^k~(1~d^\\ast)^?)\n\\end{array}",
    "v128.and": "The description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "v128.andnot": "The description of the operation iandnot_N(i_1, i_2) is:\n\nReturn the bitwise conjunction of i_1 and the bitwise negation of i_2.\n\n\\begin{array}{@lcll}\niandnot_N(i_1, i_2) &=& iand_N(i_1, inot_N(i_2))\n\\end{array}",
    "v128.any_true": "The description of the operation ine is:\n\nReturn 1 if i_1 does not equal i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nine_N(i_1, i_2) &=& bool(i_1 \\neq i_2)\n\\end{array}\n\n\nThe description of the operation Boolean Interpretation is:\n\nThe integer result of predicates – i.e., tests and relational operators – is defined with the help of the following auxiliary function producing the value 1 or 0 depending on a condition.\n\n\\begin{array}{lll@{\\qquad}l}\nbool(C) &=& 1 & (\\mathrel{if} C) \\\\\nbool(C) &=& 0 & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "v128.bitselect": "The description of the operation ibitselect_N(i_1, i_2, i_3) is:\n\nLet j_1 be the bitwise conjunction of i_1 and i_3.\n\nLet j_3' be the bitwise negation of i_3.\n\nLet j_2 be the bitwise conjunction of i_2 and j_3'.\n\nReturn the bitwise disjunction of j_1 and j_2.\n\n\\begin{array}{@lcll}\nibitselect_N(i_1, i_2, i_3) &=& ior_N(iand_N(i_1, i_3), iand_N(i_2, inot_N(i_3)))\n\\end{array}",
    "v128.load": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation Storage is:\n\nWhen a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:\n\n\\begin{array}{lll@{\\qquad}l}\nbytes_t(i) &=& littleendian(bits_t(i)) \\\\[1ex]\nlittleendian(\\epsilon) &=& \\epsilon \\\\\nlittleendian(d^8~{d'}^\\ast~) &=& littleendian({d'}^\\ast)~ibits_8^{-1}(d^8) \\\\\n\\end{array}\n\n\n\nAgain these functions are invertible bijections.",
    "v128.load16x4_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation iq15mulrsat\\_s_N(i_1, i_2) is:\n\nReturn the result of sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15)).\n\n\\begin{array}{lll@{\\qquad}l}\niq15mulrsat\\_s_N(i_1, i_2) &=& sat^{s}_N(ishr\\_s_N(i_1 \\cdot i_2 + 2^{14}, 15))\n\\end{array}",
    "v128.load16x4_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation isubsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of subtracting i_2 from i_1.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 - i_2)\n\\end{array}",
    "v128.load32x2_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ishr\\_s_N(i_1, i_2) is:\n\nLet k be i_2 modulo N.\n\nReturn the result of shifting i_1 right by k bits, extended with the most significant bit of the original value.\n\n\\begin{array}{@lcll}\nishr\\_s_N(i_1, i_2) &=& ibits_N^{-1}(d_0^{k+1}~d_1^{N-k-1})\n  & (\\mathrel{if} ibits_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \\wedge k = i_2 \\mathbin{mod} N)\n\\end{array}",
    "v128.load32x2_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ile\\_u_N(i_1, i_2) is:\n\nReturn 1 if i_1 is less than or equal to i_2, 0 otherwise.\n\n\\begin{array}{@lcll}\nile\\_u_N(i_1, i_2) &=& bool(i_1 \\leq i_2)\n\\end{array}",
    "v128.load32_zero": "The description of the operation extend^{u} is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation ipopcnt_N(i) is:\n\nReturn the count of non-zero bits in i.\n\n\\begin{array}{@lcll}\nipopcnt_N(i) &=& k & (\\mathrel{if} ibits_N(i) = (0^\\ast~1)^k~0^\\ast)\n\\end{array}",
    "v128.load64_zero": "The description of the operation extend^{u} is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation Sign Interpretation is:\n\nInteger operators are defined on iN values.\nOperators that use a signed interpretation convert the value using the following definition, which takes the two’s complement when the value lies in the upper half of the value range (i.e., its most significant bit is 1):\n\n\\begin{array}{lll@{\\qquad}l}\nsigned_N(i) &=& i & (0 \\leq i < 2^{N-1}) \\\\\nsigned_N(i) &=& i - 2^N & (2^{N-1} \\leq i < 2^N) \\\\\n\\end{array}\n\n\n\nThis function is bijective, and hence invertible.",
    "v128.load8x8_s": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation isubsat\\_s_N(i_1, i_2) is:\n\nLet j_1 be the signed interpretation of i_1\n\nLet j_2 be the signed interpretation of i_2\n\nLet j be the result of subtracting j_2 from j_1.\n\nReturn sat^{s}_N(j).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_s_N(i_1, i_2) &=& sat^{s}_N(signed_N(i_1) - signed_N(i_2))\n\\end{array}",
    "v128.load8x8_u": "The description of the operation extend is:\n\nReturn i.\n\n\\begin{array}{lll@{\\qquad}l}\nextend^{u}_{M,N}(i) &=& i \\\\\n\\end{array}\n\n\n\nIn the abstract syntax, unsigned extension just reinterprets the same value.\n\n\nThe description of the operation isubsat\\_u_N(i_1, i_2) is:\n\nLet i be the result of subtracting i_2 from i_1.\n\nReturn sat^{u}_N(i).\n\n\\begin{array}{lll@{\\qquad}l}\nisubsat\\_u_N(i_1, i_2) &=& sat^{u}_N(i_1 - i_2)\n\\end{array}",
    "v128.not": "The description of the operation NaN Propagation is:\n\nWhen the result of a floating-point operator other than fneg, fabs, or fcopysign is a NaN,\nthen its sign is non-deterministic and the payload is computed as follows:\n\nIf the payload of all NaN inputs to the operator is canonical (including the case that there are no NaN inputs), then the payload of the output is canonical as well.\n\nOtherwise the payload is picked non-deterministically among all arithmetic NaNs; that is, its most significant bit is 1 and all others are unspecified.\n\nThis non-deterministic result is expressed by the following auxiliary function producing a set of allowed outputs from a set of inputs:\n\n\\begin{array}{lll@{\\qquad}l}\nnans_N\\{z^\\ast\\} &=& \\{ + nan(n), - nan(n) ~|~ n = canon_N \\}\n  & (\\mathrel{if} \\forall nan(n) \\in z^\\ast,~ n = canon_N) \\\\\nnans_N\\{z^\\ast\\} &=& \\{ + nan(n), - nan(n) ~|~ n \\geq canon_N \\}\n  & (\\mathrel{otherwise}) \\\\\n\\end{array}",
    "v128.or": "The description of the operation ior_N(i_1, i_2) is:\n\nReturn the bitwise disjunction of i_1 and i_2.\n\n\\begin{array}{@lcll}\nior_N(i_1, i_2) &=& ibits_N^{-1}(ibits_N(i_1) \\vee ibits_N(i_2))\n\\end{array}",
    "v128.store": "The description of the operation wrap is:\n\nReturn i modulo 2^N.\n\n\\begin{array}{lll@{\\qquad}l}\nwrap_{M,N}(i) &=& i \\mathbin{mod} 2^N \\\\\n\\end{array}\n\n\nThe description of the operation Storage is:\n\nWhen a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:\n\n\\begin{array}{lll@{\\qquad}l}\nbytes_t(i) &=& littleendian(bits_t(i)) \\\\[1ex]\nlittleendian(\\epsilon) &=& \\epsilon \\\\\nlittleendian(d^8~{d'}^\\ast~) &=& littleendian({d'}^\\ast)~ibits_8^{-1}(d^8) \\\\\n\\end{array}\n\n\n\nAgain these functions are invertible bijections.",
    "v128.xor": "The description of the operation ixor_N(i_1, i_2) is:\n\nReturn the bitwise exclusive disjunction of i_1 and i_2.\n\n\\begin{array}{@lcll}\nixor_N(i_1, i_2) &=& ibits_N^{-1}(ibits_N(i_1) \\veebar ibits_N(i_2))\n\\end{array}"
}